{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"manual/06-MIPS-IDE-Projects/","text":"This chapter contains a description of projects in RISC-V Studio\u2122 IDE. A project is a logical construct that facilitates building a collection of C and/or assembly files into an executable image. Creating Projects \u00b6 Creating Source Files \u00b6 Creating new source files for a library project is straightforward; simply follow the file creation instructions found in Chapter 7. The examples that follow in this chapter are focused on importing existing files, which is typically the more common operation. Importing Source Files \u00b6 Building the Executable \u00b6 Creating an RISC-V Embedded Linux Project \u00b6 Creating an RISC-V Embedded Linux project is very similar to creating a standalone project \u2013 the biggest difference is the project type selection in the creation process. RISC-V Embedded Linux projects come with source files from the respective RTOS to enable successful generation of an executable utilizing the API from said RTOS. Below is the new project wizard dialog, which has selections for both types of projects. You can see that RISC-V Embedded Linux, and Standalone Embedded are two project types supported by RISC-V Studio\u2122 IDE in Figure 40. Figure 40 - RISC-V Project Types Supported by RISC-V Studio\u2122 IDE Note the Debug and Release options in the dialog. These options allow RISC-V Studio\u2122 IDE to manage two different configurations of the same project. The Debug configuration typically contains settings appropriate for developing and debugging the code in the project, while the Release configuration typically has settings appropriate for finished production code\u2014the main difference being the lack of debug symbols and perhaps higher optimization settings in the Release configuration. The examples in this guide use the Debug configuration. Creating Source Files \u00b6 Creating new source files for an executable project is straightforward; simply follow the file creation instructions found in Chapter 7. The examples that follow in this chapter are focused on importing existing files, which is typically the more common operation. Importing Source Files \u00b6 Importing files into newly created project is straightforward; simply drag and drop the desired files into the project. Files may also be imported to the project through menu selections. To explicitly import one or more files, \u201cright-click\u201d on the project as shown below and select the Import menu selection as shown in Figure 41. Figure 41 - Import Menu Selection Once Import is selected, RISC-V Studio\u2122 IDE displays the Import dialog, showing many options for the source of the files to import. Generally, the \u201cFile System\u201d option is the most used source for importing. Select this option to import one or more files from the file system into your project. The File System Import dialog is now displayed. Next, expand the \u201cGeneral\u201d folder, select \u201cFile System,\u201d and select the \u201cNext\u201d button. Simply use the Browse button to navigate to the specific folder containing the source files to import, select the files to import within that directory, and select \u201cFinish.\u201d You will now observe the selected files being imported into the selected project. At this point, all the necessary files for building an RISC-V Embedded Linux executable for RISC-V MCUs are contained in the project. Note that additional files might be required for executable projects and are specified in the linker settings dialogs. Such files include linker control files and the desired library files to be linked with the executable project. Building the Executable \u00b6 To build the executable, first ensure that the Console tab is selected. This makes it possible to view the progress of the executable build since the actual RISC-V C compiler invocation for each source file and the linker invocation is displayed in the Console view. Next, simply select the Build button to build the executable. Note that the default project settings are for a specific combination of RISC-V MCU device architecture, device, and hardware debug tools. To select a different combination, please refer to the subsequent section in this chapter called Modifying Projects. Once selected, observe compilation and linkage commands in the Console. At this point, the RISC-V Embedded Linux executable is ready for program, execution, and debug. Chapter 7 of this guide contains details of the program and debug processes. Closing Projects \u00b6 If a specific project is not currently needed, it is easily closed by right-clicking on the desired project to close and then clicking on the \u201cClose Project\u201d selection, as shown below in Figure 42: Figure 42 - Closing Project Menu Selection Below is the C/C++ perspective with the project in a closed state. Figure 43 - C/C++ Perspective in Closed State Modifying Projects \u00b6 There are many build options available for RISC-V Studio\u2122 IDE for RISC-V MCUs developers. The options are available through the Properties dialog. To bring up the Properties dialog, right click on the project name and then select \u201cProperties,\u201d as shown below in Figure 44. Figure 44 - Project Properties Selection Selecting \u201cProperties\u201d results in RISC-V Studio\u2122 IDE bringing up the Properties dialog. This dialog has many configuration options, however, the most typically used options are found within the \u201cC/C++ Build -Settings\u201d selection, shown here in Figure 45. Figure 45 - C/C++ Build / Settings Selection Device and Tool Settings \u00b6 N/A. RISC-V C Compiler Settings \u00b6 The high-level overview of the current C Compiler settings is shown below in Figure 47. Figure 47 - C Compiler High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the compiler is going to be invoked for this project. All files with a \u201c.c\u201d extension will be built, by default, with these options. General Settings \u00b6 The General settings dialog contains options enabling you to control various aspect of code and debug symbol generation by the compiler. You can also define additional pre-processor symbols, as well as include directory search path. An overview of the general setting dialog is shown below in Figure 48. Figure 48 - C Compiler General Settings Errors and Warning Settings \u00b6 This dialog allows you to control various error and warning reporting aspect of the compiler, as shown below in Figure 49. Figure 49 - C Compiler Errors and Warnings Settings Optimization Settings \u00b6 The optimization settings dialog allows you to change the optimization level of code generated by the compiler. Note that you will need to upgrade to a paid version of the compiler in order to access the full optimization settings of the compiler. RISC-V Linker Settings \u00b6 The high-level overview of the current C Linker settings is shown below in Figure 50. Figure 50 - Linker High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the linker is going to be invoked for this project. All executables, by default, will be linked with these options. General Options \u00b6 The General Options allows you to control the heap and stack size, as well as to write in additional options not covered by the dialog. A view of the General Option dialog is shown below in Figure 51. Figure 51 - Linker General Options Symbols and Macros \u00b6 This option group lets you introduce additional linker symbols, as well as pre-processor macro definition used during the linking process, as shown in Figure 52. Figure 52 - Symbols and Macros Settings Libraries Options \u00b6 These options, shown in Figure 53, let you specify one or more standard libraries to link with the project executable. In the event that one or more libraries are not part of the RISC-V toolchain (i.e. they reside in a different directory), you can also specify one or more search paths for the libraries. Other options include the ability to exclude standard libraries, start-up code, or floating point library. Note that the selections in the Libraries dialog specify the \u201cc\u201d and \u201cgcc\u201d libraries. It is the GNU linker than then prepends the \u201clib\u201d modifier to the library names specified and thus expects to find \u201clibc.a\u201d and \u201clibgcc.a\u201d library files in one of the specified library paths. RISC-V Studio\u2122 IDE also makes it possible to specify the path and actual name of library files. The \u201cAdditional Inputs (*.o/*.lib)\u201d dialog is used to do this. Please note that references to actual path on your host computer will make your project/workspace not portable to other host systems. Figure 53 - Library Options Diagnostic Options \u00b6 These options, shown in Figure 54, let you generate extra reports about the executable, including memory usages, files crossed referenced, and one or more trace symbol(s). Figure 54 - Diagnostic Options RISC-V Assembler Settings \u00b6 These settings let you control various aspects of the assembler. A general view is shown below in Figure 55. Figure 55 - Assembler General View As with compiler and linker settings, the \u201cCommand\u201d and \u201cAll Options\u201d show exactly how the assembler is to be invoked for files ending with \u201c.s\u201d extension in the selected project. General Settings \u00b6 The General settings let you define preprocessor macros, as well as assembler symbols and search paths, as shown below in Figure 56. Figure 56 - Assembler General Settings Other Options \u00b6 The Other options let you tune various parameters of the assembler, as shown in Figure 57. Figure 57 - Assembler Other Options Deleting Projects \u00b6 Deleting a project is done by right clicking on the project and selecting \u201cDelete\u201d Once \u201cDelete\u201d is selected, RISC-V Studio\u2122 IDE presents a dialog that specifies whether or not everything in the project directory is to be deleted. If the contents are not deleted, they may be used in a subsequent creation of another project.","title":"06 MIPS IDE Projects"},{"location":"manual/06-MIPS-IDE-Projects/#creating-projects","text":"","title":"Creating Projects"},{"location":"manual/06-MIPS-IDE-Projects/#creating-source-files","text":"Creating new source files for a library project is straightforward; simply follow the file creation instructions found in Chapter 7. The examples that follow in this chapter are focused on importing existing files, which is typically the more common operation.","title":"Creating Source Files"},{"location":"manual/06-MIPS-IDE-Projects/#importing-source-files","text":"","title":"Importing Source Files"},{"location":"manual/06-MIPS-IDE-Projects/#building-the-executable","text":"","title":"Building the Executable"},{"location":"manual/06-MIPS-IDE-Projects/#creating-an-risc-v-embedded-linux-project","text":"Creating an RISC-V Embedded Linux project is very similar to creating a standalone project \u2013 the biggest difference is the project type selection in the creation process. RISC-V Embedded Linux projects come with source files from the respective RTOS to enable successful generation of an executable utilizing the API from said RTOS. Below is the new project wizard dialog, which has selections for both types of projects. You can see that RISC-V Embedded Linux, and Standalone Embedded are two project types supported by RISC-V Studio\u2122 IDE in Figure 40. Figure 40 - RISC-V Project Types Supported by RISC-V Studio\u2122 IDE Note the Debug and Release options in the dialog. These options allow RISC-V Studio\u2122 IDE to manage two different configurations of the same project. The Debug configuration typically contains settings appropriate for developing and debugging the code in the project, while the Release configuration typically has settings appropriate for finished production code\u2014the main difference being the lack of debug symbols and perhaps higher optimization settings in the Release configuration. The examples in this guide use the Debug configuration.","title":"Creating an RISC-V Embedded Linux Project"},{"location":"manual/06-MIPS-IDE-Projects/#creating-source-files_1","text":"Creating new source files for an executable project is straightforward; simply follow the file creation instructions found in Chapter 7. The examples that follow in this chapter are focused on importing existing files, which is typically the more common operation.","title":"Creating Source Files"},{"location":"manual/06-MIPS-IDE-Projects/#importing-source-files_1","text":"Importing files into newly created project is straightforward; simply drag and drop the desired files into the project. Files may also be imported to the project through menu selections. To explicitly import one or more files, \u201cright-click\u201d on the project as shown below and select the Import menu selection as shown in Figure 41. Figure 41 - Import Menu Selection Once Import is selected, RISC-V Studio\u2122 IDE displays the Import dialog, showing many options for the source of the files to import. Generally, the \u201cFile System\u201d option is the most used source for importing. Select this option to import one or more files from the file system into your project. The File System Import dialog is now displayed. Next, expand the \u201cGeneral\u201d folder, select \u201cFile System,\u201d and select the \u201cNext\u201d button. Simply use the Browse button to navigate to the specific folder containing the source files to import, select the files to import within that directory, and select \u201cFinish.\u201d You will now observe the selected files being imported into the selected project. At this point, all the necessary files for building an RISC-V Embedded Linux executable for RISC-V MCUs are contained in the project. Note that additional files might be required for executable projects and are specified in the linker settings dialogs. Such files include linker control files and the desired library files to be linked with the executable project.","title":"Importing Source Files"},{"location":"manual/06-MIPS-IDE-Projects/#building-the-executable_1","text":"To build the executable, first ensure that the Console tab is selected. This makes it possible to view the progress of the executable build since the actual RISC-V C compiler invocation for each source file and the linker invocation is displayed in the Console view. Next, simply select the Build button to build the executable. Note that the default project settings are for a specific combination of RISC-V MCU device architecture, device, and hardware debug tools. To select a different combination, please refer to the subsequent section in this chapter called Modifying Projects. Once selected, observe compilation and linkage commands in the Console. At this point, the RISC-V Embedded Linux executable is ready for program, execution, and debug. Chapter 7 of this guide contains details of the program and debug processes.","title":"Building the Executable"},{"location":"manual/06-MIPS-IDE-Projects/#closing-projects","text":"If a specific project is not currently needed, it is easily closed by right-clicking on the desired project to close and then clicking on the \u201cClose Project\u201d selection, as shown below in Figure 42: Figure 42 - Closing Project Menu Selection Below is the C/C++ perspective with the project in a closed state. Figure 43 - C/C++ Perspective in Closed State","title":"Closing Projects"},{"location":"manual/06-MIPS-IDE-Projects/#modifying-projects","text":"There are many build options available for RISC-V Studio\u2122 IDE for RISC-V MCUs developers. The options are available through the Properties dialog. To bring up the Properties dialog, right click on the project name and then select \u201cProperties,\u201d as shown below in Figure 44. Figure 44 - Project Properties Selection Selecting \u201cProperties\u201d results in RISC-V Studio\u2122 IDE bringing up the Properties dialog. This dialog has many configuration options, however, the most typically used options are found within the \u201cC/C++ Build -Settings\u201d selection, shown here in Figure 45. Figure 45 - C/C++ Build / Settings Selection","title":"Modifying Projects"},{"location":"manual/06-MIPS-IDE-Projects/#device-and-tool-settings","text":"N/A.","title":"Device and Tool Settings"},{"location":"manual/06-MIPS-IDE-Projects/#risc-v-c-compiler-settings","text":"The high-level overview of the current C Compiler settings is shown below in Figure 47. Figure 47 - C Compiler High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the compiler is going to be invoked for this project. All files with a \u201c.c\u201d extension will be built, by default, with these options.","title":"RISC-V C Compiler Settings"},{"location":"manual/06-MIPS-IDE-Projects/#general-settings","text":"The General settings dialog contains options enabling you to control various aspect of code and debug symbol generation by the compiler. You can also define additional pre-processor symbols, as well as include directory search path. An overview of the general setting dialog is shown below in Figure 48. Figure 48 - C Compiler General Settings","title":"General Settings"},{"location":"manual/06-MIPS-IDE-Projects/#errors-and-warning-settings","text":"This dialog allows you to control various error and warning reporting aspect of the compiler, as shown below in Figure 49. Figure 49 - C Compiler Errors and Warnings Settings","title":"Errors and Warning Settings"},{"location":"manual/06-MIPS-IDE-Projects/#optimization-settings","text":"The optimization settings dialog allows you to change the optimization level of code generated by the compiler. Note that you will need to upgrade to a paid version of the compiler in order to access the full optimization settings of the compiler.","title":"Optimization Settings"},{"location":"manual/06-MIPS-IDE-Projects/#risc-v-linker-settings","text":"The high-level overview of the current C Linker settings is shown below in Figure 50. Figure 50 - Linker High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the linker is going to be invoked for this project. All executables, by default, will be linked with these options.","title":"RISC-V Linker Settings"},{"location":"manual/06-MIPS-IDE-Projects/#general-options","text":"The General Options allows you to control the heap and stack size, as well as to write in additional options not covered by the dialog. A view of the General Option dialog is shown below in Figure 51. Figure 51 - Linker General Options","title":"General Options"},{"location":"manual/06-MIPS-IDE-Projects/#symbols-and-macros","text":"This option group lets you introduce additional linker symbols, as well as pre-processor macro definition used during the linking process, as shown in Figure 52. Figure 52 - Symbols and Macros Settings","title":"Symbols and Macros"},{"location":"manual/06-MIPS-IDE-Projects/#libraries-options","text":"These options, shown in Figure 53, let you specify one or more standard libraries to link with the project executable. In the event that one or more libraries are not part of the RISC-V toolchain (i.e. they reside in a different directory), you can also specify one or more search paths for the libraries. Other options include the ability to exclude standard libraries, start-up code, or floating point library. Note that the selections in the Libraries dialog specify the \u201cc\u201d and \u201cgcc\u201d libraries. It is the GNU linker than then prepends the \u201clib\u201d modifier to the library names specified and thus expects to find \u201clibc.a\u201d and \u201clibgcc.a\u201d library files in one of the specified library paths. RISC-V Studio\u2122 IDE also makes it possible to specify the path and actual name of library files. The \u201cAdditional Inputs (*.o/*.lib)\u201d dialog is used to do this. Please note that references to actual path on your host computer will make your project/workspace not portable to other host systems. Figure 53 - Library Options","title":"Libraries Options"},{"location":"manual/06-MIPS-IDE-Projects/#diagnostic-options","text":"These options, shown in Figure 54, let you generate extra reports about the executable, including memory usages, files crossed referenced, and one or more trace symbol(s). Figure 54 - Diagnostic Options","title":"Diagnostic Options"},{"location":"manual/06-MIPS-IDE-Projects/#risc-v-assembler-settings","text":"These settings let you control various aspects of the assembler. A general view is shown below in Figure 55. Figure 55 - Assembler General View As with compiler and linker settings, the \u201cCommand\u201d and \u201cAll Options\u201d show exactly how the assembler is to be invoked for files ending with \u201c.s\u201d extension in the selected project.","title":"RISC-V Assembler Settings"},{"location":"manual/06-MIPS-IDE-Projects/#general-settings_1","text":"The General settings let you define preprocessor macros, as well as assembler symbols and search paths, as shown below in Figure 56. Figure 56 - Assembler General Settings","title":"General Settings"},{"location":"manual/06-MIPS-IDE-Projects/#other-options","text":"The Other options let you tune various parameters of the assembler, as shown in Figure 57. Figure 57 - Assembler Other Options","title":"Other Options"},{"location":"manual/06-MIPS-IDE-Projects/#deleting-projects","text":"Deleting a project is done by right clicking on the project and selecting \u201cDelete\u201d Once \u201cDelete\u201d is selected, RISC-V Studio\u2122 IDE presents a dialog that specifies whether or not everything in the project directory is to be deleted. If the contents are not deleted, they may be used in a subsequent creation of another project.","title":"Deleting Projects"},{"location":"manual/About-This-Guide/","text":"About The User Guide \u00b6 Welcome to RISC-V Studio \u2122 , an Eclipse-based development tool for the RISC-V ecosystem The RISC-V Studio\u2122 Integrated Development Environment (IDE) is a flexible and highly configurable software environment that helps the RISC-V developers discover, configure, develop, debug and deploy system designs utilizing open-source and commercial RISC-V IPs and platforms. RISC-V Studio\u2122 works seamlessly with the ecosystem of plugins that are freely available from the Eclipse marketplace . RISC-V Studio\u2122 provides uniques features to save time and improve productivity. It is highly recommended that users be familiar with standard embedded development concepts, practices, and programming languages (C, C++, python). Highlights \u00b6 RISC-V Discovery - select compatible RISC-V IPs and peripherals to deploy on your hardware platforms. Cross-platform Toolchains - utilize tested and optimized RISC-V toolchains and run-time environment to build your RISC-V application binaries from Linux and Windows hosts. Integrated Managed Build - create and customize complex embedded RISC-V applications with a few simple clicks. Debug and Deploy - program RISC-V IPs, download and debug applications with a simple, consistent, and easy-to-use framework. Enhance Visibility - visualize and discover more about the RISC-V platform with the registers viewer, or about the application states with the RTOS objects inspector. License \u00b6 Use of RISC-V Studio is governed by terms under a separate license agreements that are not inclusive as part of this User Guide. Guide Conventions \u00b6 Italics typeface denotes book titles, emphasizes important words, and indicates variables. Boldface typeface denotes file names, key words, and further emphasizes important words and variables.","title":"About This Guide"},{"location":"manual/About-This-Guide/#about-the-user-guide","text":"Welcome to RISC-V Studio \u2122 , an Eclipse-based development tool for the RISC-V ecosystem The RISC-V Studio\u2122 Integrated Development Environment (IDE) is a flexible and highly configurable software environment that helps the RISC-V developers discover, configure, develop, debug and deploy system designs utilizing open-source and commercial RISC-V IPs and platforms. RISC-V Studio\u2122 works seamlessly with the ecosystem of plugins that are freely available from the Eclipse marketplace . RISC-V Studio\u2122 provides uniques features to save time and improve productivity. It is highly recommended that users be familiar with standard embedded development concepts, practices, and programming languages (C, C++, python).","title":"About The User Guide"},{"location":"manual/About-This-Guide/#highlights","text":"RISC-V Discovery - select compatible RISC-V IPs and peripherals to deploy on your hardware platforms. Cross-platform Toolchains - utilize tested and optimized RISC-V toolchains and run-time environment to build your RISC-V application binaries from Linux and Windows hosts. Integrated Managed Build - create and customize complex embedded RISC-V applications with a few simple clicks. Debug and Deploy - program RISC-V IPs, download and debug applications with a simple, consistent, and easy-to-use framework. Enhance Visibility - visualize and discover more about the RISC-V platform with the registers viewer, or about the application states with the RTOS objects inspector.","title":"Highlights"},{"location":"manual/About-This-Guide/#license","text":"Use of RISC-V Studio is governed by terms under a separate license agreements that are not inclusive as part of this User Guide.","title":"License"},{"location":"manual/About-This-Guide/#guide-conventions","text":"Italics typeface denotes book titles, emphasizes important words, and indicates variables. Boldface typeface denotes file names, key words, and further emphasizes important words and variables.","title":"Guide Conventions"},{"location":"manual/Assembler-General-Settings/","text":"Assembler Settings \u00b6 These settings let you control various aspects of the assembler. A general view is shown below in Figure 55. Figure 55 - Assembler General View As with compiler and linker settings, the \u201cCommand\u201d and \u201cAll Options\u201d show exactly how the assembler is to be invoked for files ending with \u201c.s\u201d extension in the selected project. General Settings \u00b6 The General settings let you define preprocessor macros, as well as assembler symbols and search paths, as shown below in Figure 56. Figure 56 - Assembler General Settings","title":"Assembler General Settings"},{"location":"manual/Assembler-General-Settings/#assembler-settings","text":"These settings let you control various aspects of the assembler. A general view is shown below in Figure 55. Figure 55 - Assembler General View As with compiler and linker settings, the \u201cCommand\u201d and \u201cAll Options\u201d show exactly how the assembler is to be invoked for files ending with \u201c.s\u201d extension in the selected project.","title":"Assembler Settings"},{"location":"manual/Assembler-General-Settings/#general-settings","text":"The General settings let you define preprocessor macros, as well as assembler symbols and search paths, as shown below in Figure 56. Figure 56 - Assembler General Settings","title":"General Settings"},{"location":"manual/Breakpoint/","text":"Stopping the program at certain locations in the source code is a necessity and is easily accomplished in RISC-V Studio\u2122 IDE via the breakpoint. Breakpoints are set and cleared by double-clicking on the left margin of the source window. When the program hits the breakpoint it is halted and all the pertinent register and data views are updated. Selecting the \u201cResume\u201d button again will cause the demonstration program to run again. As mentioned previously, breakpoints can be removed simply by double-clicking on them. Alternatively, they can be removed or disabled via the \u201cBreakpoints\u201d dialog. Right-clicking on the breakpoint in this dialog provides selections for the specific breakpoint:","title":"Breakpoint"},{"location":"manual/Build-HelloSPIProject/","text":"Similar to building the Hello World RISC-V C Project.","title":"Building Hello SPI RISC-V C Project"},{"location":"manual/Building-Blinky-the-Executable/","text":"The RISC-V Studio desktop: Building is simply done by clicking on the build button in the toolbar: The messages in the Console view:","title":"Building Blinky the Executable"},{"location":"manual/Building-BlinkyDemoHardware/","text":"The build process is similar as building the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Building RISC-V Blinky Demo on Real Hardware"},{"location":"manual/Building-Embedded-the-Executable/","text":"The RISC-V Studio desktop: Building is simply done by clicking on the build button in the toolbar: The messages in the Console view:","title":"Building Hello World RISC-V the Executable"},{"location":"manual/Building-GameOfLifeHardware/","text":"The build process is similar as building the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Building RISC-V Game of Life Demo on Real Hardware"},{"location":"manual/Building-Heap2-the-Executable/","text":"The RISC-V Studio desktop: Building is simply done by clicking on the build button in the toolbar: The messages in the Console view:","title":"Building Heap 2 the Executable"},{"location":"manual/Building-HelloworldDemoOnHardware/","text":"The build process is similar as building the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Building RISC-V Helloworld Demo on Real Hardware"},{"location":"manual/Building-SPIDemoOnHardware/","text":"The build process is similar as building the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Building RISC-V SPI Demo on Real Hardware"},{"location":"manual/Building-Timer-the-Executable/","text":"The RISC-V Studio desktop: Building is simply done by clicking on the build button in the toolbar: The messages in the Console view:","title":"Building Timer the Executable"},{"location":"manual/Building-TimerDemoOnHardware/","text":"The RISC-V Studio desktop: Building is simply done by clicking on the build button in the toolbar: The messages in the Console view:","title":"Building RISC-V General Purpose Timer Demo on Real Hardware"},{"location":"manual/Building-the-Executable-Stand-Project/","text":"To build the executable, first ensure that the Console tab is selected. This makes it possible to view the progress of the executable build since the actual RISC-V C compiler invocation for each source file and the linker invocation is displayed in the Console view. Next, simply select the Build button to build the executable. Note that the default project settings are for a specific combination of RISC-V MCU device architecture, device, and hardware debug tools. To select a different combination, please refer to the subsequent section in this chapter called Modifying Projects. Once selected, observe compilation and linkage commands in the Console. At this point, the RISC-V Embedded Linux executable is ready for program, execution, and debug. Creating & Editing Files section of this guide contains details of the program and debug processes.","title":"Building the Executable Stand Project"},{"location":"manual/Building-the-Executable/","text":"To build the executable, first ensure that the Console tab is selected. If not, the Console window can be enabled by selecting \u201cWindow -Show View -Console.\u201d The Console window displays the progress of the library build \u2013 including the actual RISC-V C compiler invocation for each source file in the library. Next, simply select the project Build button to build the executable as shown in Figure 38. Figure 38 - Build Menu Selection Note that the default project settings are for the device and hw tools selected at project creation time. For other settings, please refer to the subsequent section in this chapter titled Modifying Projects. Once selected, observe compilation commands in the Console window as shown below in Figure 39. This project products a standalone executable by the name of RISC-V_MTI_LINUX_SAMPLE.elf: Figure 39 - Build Output in Console View","title":"Building the Executable"},{"location":"manual/Building-the-Project/","text":"Display the RISC-V Studio desktop in Figure 21. Figure 21 - RISC-V Studio C/C++ Perspective Note that: \u2022You can select \u201cC/C++\u201d button to view the C perspective at all time \u2022Edit/view source files by double-clicking on it under the Project Explorer At this point, you\u2019re ready to build the RISC-V project. Note that you must install the RISC-V C compiler toolchain prior to using RISC-V Studio in order to build this RISC-V application. (For other PIC MCUs, you may need to select a different RISC-V C compiler.) Building is simply done by clicking on the build button in the toolbar, shown in Figure 22. Figure 22 - Build Button in Toolbar When building finished, display messages in the Console view of Figure 23. Figure 23 - Console View","title":"Building the Project"},{"location":"manual/C-C---Perspective/","text":"The RISC-V Studio perspective provides all the tools necessary to create, edit, assemble, compile, and link an embedded program. Below is the RISC-V Studio C/C++ perspective shown for an empty workspace (a workspace without any projects).","title":"C/C++ Perspective"},{"location":"manual/Closing-Project/","text":"Closing RISC-V Standalone Embedded Project If a specific project is not currently needed, it is easily closed by right-clicking on the desired project to close and then clicking on the \u201cClose Project\u201d selection, as shown below in Figure 42: Figure 42 - Closing Project Menu Selection Below is the C/C++ perspective with the project in a closed state. Figure 43 - C/C++ Perspective in Closed State","title":"Closing Project"},{"location":"manual/Creating-BlinkyDemoHardware/","text":"Select \u201cFile - New - C Project\u201d choose FreeRTOS Project > RISC-V Blinky Demo on Real Hardware. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select FreeRTOS Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating RISC-V Blinky Demo on Real Hardware"},{"location":"manual/Creating-GameOfLifeHardware/","text":"Select \u201cFile - New - C Project\u201d choose RISC-V Embedded Project > RISC-V Game of Life Demo on Real Hardware. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V Embedded Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating RISC-V Game of Life Demo on Real Hardware"},{"location":"manual/Creating-HelloSPIProject/","text":"Select \u201cFile - New - C Project\u201d choose RISC-V Embedded Project > Hello SPI RISC-V C Project. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V Embedded Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating Hello SPI RISC-V C Project"},{"location":"manual/Creating-HelloworldDemoOnHardware/","text":"Select \u201cFile - New - C Project\u201d choose RISC-V Embedded Project > RISC-V Helloworld Demo on Real Hardware. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V Embedded Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating RISC-V Helloworld Demo on Real Hardware"},{"location":"manual/Creating-Project/","text":"There are principally two types of projects in RISC-V Studio\u2122 IDE: standalone executable projects or Embedded Linux projects. A standalone executable is a program that does not require the services of an RTOS, whereas an RTOS executable is one that relies on the API published by the respective Real-Time Operating System. Creating a new project in RISC-V Studio\u2122 IDE is easy; simply select \u201cFile -New -Project\u201d as demonstrated in the Simple Example Project in Chapter 3. Figure 34 - RISC-V Project Type Selection Dialog Note above the different standalone and Embedded Linux project types that can be created from RISC-V Studio\u2122 IDE.","title":"Creating Project"},{"location":"manual/Creating-RISCVBlinky-Project/","text":"The easiest way to use FreeRTOS is to start with one of the pre-configured demo application projects by select \u201cFile - New - C Project\u201d choose RISC-V Blinky Demo project. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V FreeRTOS Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating Blinky Project"},{"location":"manual/Creating-RISCVEmbedded-Project/","text":"Select \u201cFile - New - C Project\u201d choose RISC-V Embedded Project > Hello World RISC-V C project:","title":"Creating Hello World RISC-V Project"},{"location":"manual/Creating-RISCVHeap2-Project/","text":"Select \u201cFile - New - C Project\u201d choose RISC-V Generic Heap 2 Demo project. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V FreeRTOS Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating Heap 2 Project"},{"location":"manual/Creating-RISCVTimer-Project/","text":"Select \u201cFile -New - C Project\u201d choose RISC-V Generic Timer Demo project. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V FreeRTOS Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating Timer Project"},{"location":"manual/Creating-SPIDemoOnHardware/","text":"Select \u201cFile - New - C Project\u201d choose RISC-V Embedded Project > RISC-V SPI Demo on Real Hardware. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V Embedded Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating RISC-V SPI Demo on Real Hardware"},{"location":"manual/Creating-Source-Files-Stand-Project/","text":"Creating new source files for an executable project is straightforward; simply follow the file creation instructions found in Creating & Editing Files section. The examples that follow in this chapter are focused on importing existing files, which is typically the more common operation.","title":"Creating Source Files Stand Project"},{"location":"manual/Creating-Source-Files/","text":"Creating new source files for a library project is straightforward; simply follow the file creation instructions found in Creating & Editing Files section. The examples that follow in this chapter are focused on importing existing files, which is typically the more common operation.","title":"Creating Source Files"},{"location":"manual/Creating-TimerDemoOnHardware/","text":"Select \u201cFile - New - C Project\u201d choose RISC-V Embedded Project > RISC-V General Purpose Timer Demo on Real Hardware. Select Toolchains: riscv-rvdn-elf and enter Project name. Then click Next. Enter Author then click Next. Select RISC-V Embedded Project configuration by default with 2 modes: release/debug > Then Finish","title":"Creating RISC-V General Purpose Timer Demo on Real Hardware"},{"location":"manual/Creating-Workspace/","text":"Creating a new workspace in RISC-V Studio is very easy and amounts to simply selecting an empty or non-existent directory. If the directory does not exist, RISC-V Studio will create it and in either case prepare the workspace for importing and/or creating new projects. Note that if you don\u2019t specify the complete root directory path, RISC-V Studio will create the workspace directory relative to the RISC-V Studio installation directory. Upon the opening of a newly created workspace, RISC-V Studio shows the Welcome screen and creates storage for the workspace in the specified location on the host computer and prepares it to import and/or create one or more projects. Welcome screen for the new empty workspace: Selecting the \u201cGo to the workbench\u201d button enters the newly created, empty workspace. An empty workspace simply has no projects and as a result the Project Explorer section is blank.","title":"Creating Workspace"},{"location":"manual/Creating-a-New-File/","text":"Creating a new file within a project is accomplished by selecting the \u201cFile -New -Other\u201d menu selection: Once selected, the new resource wizard dialog is displayed, from which \u201cFile\u201d should be selected followed by \u201cNext\u201d as shown: The resulting dialog in shows an example of creating a file named \u201cnew_file.c\u201d in the selected project. After finish is selected, the file \u201cnew_file.c\u201d is now part of the selected project:","title":"Creating a New File"},{"location":"manual/Creating-a-Project/","text":"From the RISC-V Studio workbench, you can begin to create a project for a RISC-V MCU. Start by selecting File->New->Project to show the New Project Dialog in Figure 15: Figure 15 - New Project Dialog Select \u201cC Project\u201d and click \u201cNext\u201d to continue. Figure 16 - Project Types Selection Dialog RISC-V Studio will now present a list of project types to choose from in Figure 16. You may need to check/uncheck the \u201cShow project types and toolchains\u2026\u201d checkbox to show all-available project types for RISC-V MCUs. Select \u201cRISC-V Embedded Linux Project\u201d then select \u201cHello World C Project\u201d for this exercise and enter \u201cRISC-V_LINUX\u201d for Project name. Click \u201cNext\u201d to move to the C Project Dialog, shown in Figure 17. Figure 17 - C Project Dialog","title":"Creating a Project"},{"location":"manual/Creating-an-Stand-Project/","text":"Creating an RISC-V Embedded Linux project is very similar to creating a standalone project \u2013 the biggest difference is the project type selection in the creation process. RISC-V Embedded Linux projects come with source files from the respective RTOS to enable successful generation of an executable utilizing the API from said RTOS. Below is the new project wizard dialog, which has selections for both types of projects. You can see that RISC-V Embedded Linux, and Standalone Embedded are two project types supported by RISC-V Studio\u2122 IDE in Figure 40. Figure 40 - RISC-V Project Types Supported by RISC-V Studio\u2122 IDE Note the Debug and Release options in the dialog. These options allow RISC-V Studio\u2122 IDE to manage two different configurations of the same project. The Debug configuration typically contains settings appropriate for developing and debugging the code in the project, while the Release configuration typically has settings appropriate for finished production code\u2014the main difference being the lack of debug symbols and perhaps higher optimization settings in the Release configuration. The examples in this guide use the Debug configuration.","title":"Creating an Stand Project"},{"location":"manual/Debug-BlinkyDemoHardware/","text":"The debugging process is similar as debugging the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Debug RISC-V Blinky Demo on Real Hardware"},{"location":"manual/Debug-Configurations/","text":"The Debug Configuration specifies the executable image is to be programed on the device, executed and debugged. In addition, you can specify additional GDB commands to be executed at connect time as: Startup Tab in Debug Configuration Dialog By default, RISC-V Studio\u2122 IDE initialize the debug configuration with values appropriate for the selected project when you create a new debug configuration. If a project is not selected, or if the selected project has more than one active build configuration, you will need to explicitly specify the project executable to be used at debug time.","title":"Debug Configurations"},{"location":"manual/Debug-GameOfLifeHardware/","text":"The debugging process is similar as debugging the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Debug RISC-V Game of Life Demo on Real Hardware"},{"location":"manual/Debug-HelloSPIProject/","text":"Similar to debugging the Hello World RISC-V C Project.","title":"Debug Hello SPI RISC-V C Project"},{"location":"manual/Debug-HelloworldDemoOnHardware/","text":"The debugging process is similar as debugging the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Debug RISC-V Helloworld Demo on Real Hardware"},{"location":"manual/Debug-Perspective/","text":"The RISC-V Studio Debug perspective provides all the tools necessary to debug and run an embedded program. Below is the Debug perspective for the RISC-V project:","title":"Debug Perspective"},{"location":"manual/Debug-RISC-VEmbedded-with-QEMU/","text":"Step 1: Option 1: Before debugging, select the Hello World RISC-V C project entry in the Project Explorer then opening the Debug Configuration Dialog. Doing so will enable eclipse to automatically fill out the necessary debug configuration information. Debug Configuration Dialog, create new one by double click On tab Debugger, choose option QEMU in Virtual Platforms and click Apply then Debug Option 2: Select the Hello World RISC-V C Project entry in the Project Explorer then clicking Debug As/ RISC-V application with QEMU Option 3: Right-click on current project > Debug As > RISV-C application with QEMU Step 2: IDE change to debug perspective and auto set breakpoint in the first line of code in main() function. Step 3: Open main.c source code file into src/blinky_demo > Set more breakpoint. Or you can press F5 in main_blinky() function to step into to open relate source code file. Step 4: Beside Console, Problem and Execute Tab > Open Register Page directly from click on top right icon on Register View Or Window > Preference > C/C++ > Register Page Step 5: Select Architecture: RISCV, Vendor: QEMU, Platform: qemu Select all Register or some Register that you want to check debug info Click Apply and Close Step 6: Press F8 to go to next breakpoint. Step 7: Click on each register component on Register View to get debug info Step 8: Continue to debug with F6 for step over Step 9: Continue to debug with F5 for step into line of code and see data change in Register View Step 10: Terminate debug process by click Terminate icon in toolbar","title":"Debug Hello World RISC-V Project"},{"location":"manual/Debug-SPIDemoOnHardware/","text":"The debugging process is similar as debugging the RISC-V General Purpose Timer Demo on Real Hardware .","title":"Debug RISC-V SPI Demo on Real Hardware"},{"location":"manual/Debug-TimerDemoOnHardware/","text":"Step 1: Open Programming IP Core then click Finish to start Altera board flash: The messages in the Console view: Debugging: Before debugging, select RISC-V General Purpose Timer Demo on Real Hardware entry in the Project Explorer then opening the Debug Configuration Dialog. Doing so will enable eclipse to automatically fill out the necessary debug configuration information. Debug Configuration Dialog, create new one by double click On tab Debugger, choose option Altera Board in FPGA. On Default Configuration box: Select DP BusBluster v3, click Apply Then click Debug. Step 2: RISC-V Studio change to debug perspective and auto set breakpoint in the first line of code in main() function. Step 3: Set more breakpoint. Step 4: Press F8 to go to next breakpoint. Step 5: Continue to debug with F5 for step into line of code. Step 6: Continue to debug with F6 for step over Step 7: Continue to debug with F7 for step return file .c Step 8: Terminate debug process by click Terminate icon in toolbar or press Ctrl + F2 Note: If you want to restart the debug session, the RISC-V CPU need to be reset. Todo so, please click KEY0 on the board (Altera DE2-115/Altera DE10-Lite) or reflash the RISC-V image","title":"Debug RISC-V General Purpose Timer Demo on Real Hardware"},{"location":"manual/Debug-blinky-with-QEMU/","text":"Step 1: Before debugging, select the RISC-V Blinky Demo entry in the Project Explorer then opening the Debug Configuration Dialog. Doing so will enable eclipse to automatically fill out the necessary debug configuration information. Debug Configuration Dialog, create new one by double click On tab Debugger, choose option QEMU in Virtual Platforms. On Machine box, select sifive_e and click Apply then Debug. Step 2: IDE change to debug perspective and auto set breakpoint in the first line of code in main() function. Step 3: Open main_blinky.c source code file into src/blinky_demo > Set more breakpoint in Task and Queue object. Or you can press F5 in main_blinky() function to step into to open relate source code file. Step 4: Beside Console, Problem and Execute Tab > Open Peripheral registers Tab > Open Registers Page directly from click on top right icon on Register View. Or Window > Preference > C/C++ > Debug > Peripheral Registers Page Step 5: Select Architecture: RISCV, Vendor: SiFive, Platform: FE310 Or select Architecture: RISCV, Vendor: QEMU, Platform: Spike or E31mc or E31 Select all Registers or some Registers that you want to check debug info Click Apply and Close Step 6: Press F8 to go to next breakpoint. Step 7: Click on each register component on Register View to get debug info Step 8: Continue to debug with F6 for step over Step 9: Continue to debug with F5 for step into line of code and see data change in Register View Step 10: Open Object Task, Queue, Heap to see detail information: Task: Queue: Heap: Step 11: Terminate debug process by click Terminate icon in toolbar","title":"Debug Blinky Project"},{"location":"manual/Debug-heap2-with-QEMU/","text":"Step 1: Before debugging, select the RISC-V Generic Heap 2 Demo entry in the Project Explorer then opening the Debug Configuration Dialog. Doing so will enable eclipse to automatically fill out the necessary debug configuration information. Debug Configuration Dialog, create new one by double click On tab Debugger, choose option QEMU in Virtual Platforms. On Machine box, select sifive_e and click Apply then Debug. Step 2: IDE change to debug perspective and auto set breakpoint in the first line of code in main() function. Step 3: Open main_blinky.c source code file into src/blinky_demo > Set more breakpoint in Task and Queue object. Or you can press F5 in main_blinky() function to step into to open relate source code file. Step 4: Beside Console, Problem and Execute Tab > Open Peripheral registers Tab > Open Registers Page directly from click on top right icon on Register View. Or Window > Preference > C/C++ > Debug > Peripheral Registers Page Step 5: Select Architecture: RISCV, Vendor: SiFive, Platform: FE310 Or select Architecture: RISCV, Vendor: QEMU, Platform: Spike or E31mc or E31 Select all Registers or some Registers that you want to check debug info Click Apply and Close Step 6: Press F8 to go to next breakpoint. Step 7: Click on each register component on Register View to get debug info Step 8: Continue to debug with F6 for step over Step 9: Continue to debug with F5 for step into line of code and see data change in Register View Step 10: Open Object Task, Queue, Heap to see detail information: Task: Queue: Heap: Step 11: Terminate debug process by click Terminate icon in toolbar","title":"Debug Heap 2 Project"},{"location":"manual/Debug-timer-with-QEMU/","text":"Step 1: Before debugging, select the RISC-V Generic Timer Demo entry in the Project Explorer then opening the Debug Configuration Dialog. Doing so will enable eclipse to automatically fill out the necessary debug configuration information. Debug Configuration Dialog, create new one by double click On tab Debugger, choose option QEMU in Virtual Platforms. On Machine box, select sifive_e and click Apply then Debug. Step 2: IDE change to debug perspective and auto set breakpoint in the first line of code in main() function. Step 3: Open main_blinky.c source code file into src/blinky_demo > Set more breakpoint in Task and Queue object. Or you can press F5 in main_blinky() function to step into to open relate source code file. Step 4: Beside Console, Problem and Execute Tab > Open Peripheral registers Tab > Open Registers Page directly from click on top right icon on Register View. Or Window > Preference > C/C++ > Debug > Peripheral Registers Page Step 5: Select Architecture: RISCV, Vendor: SiFive, Platform: FE310 Or select Architecture: RISCV, Vendor: QEMU, Platform: Spike or E31mc or E31 Select all Registers or some Registers that you want to check debug info Click Apply and Close Step 6: Press F8 to go to next breakpoint. Step 7: Click on each register component on Register View to get debug info Step 8: Continue to debug with F6 for step over Step 9: Continue to debug with F5 for step into line of code and see data change in Register View Step 10: Open Object Task, Queue, Timer, Heap to see detail information: Task: Queue: Timer: Heap: Step 11: Terminate debug process by click Terminate icon in toolbar","title":"Debug Timer Project"},{"location":"manual/Debugging-the-Project/","text":"Before you debug, it is recommended that you select the RISC-V entry in the Project Explorer, as shown in Figure 24, before opening the Debug Configuration Dialog. Doing so will enable eclipse to automatically fill out the necessary debug configuration information. Figure 24 - Debug Configuration Dialog Now you can debug the \u201cRISC-V\u201d application by selecting Debug->Debug Configurations, or by clicking on the tiny down arrow next to the cockroach and select \u201cDebug Configurations\u201d as shown in Figure 25. Figure 25 - Opening Debug Configuration Dialog From the Debug Configuration Dialog: \u2022 Select RISC-V Config in the launch list \u2022 Double click on the plus icon in the toolbar to create a new debug configuration for the RISC-V project You should see the Main Debug Tab shown in Figure 26: Figure 26 - Main Debug Tab At this point, RISC-V Studio should offer the Debug perspective and you shall accept, as shown in Figure 27 Figure 27 - Switching to Debug Perspective From the Debug perspective shown in Figure 28, you can press \u201cResume\u201d button to resume execution, or \u201cHalt\u201d to suspend execution. Notice that the debug view should annotate your current program location within the execution flow. In addition, breakpoints, register, and memory viewing are all available with just a few mouse clicks! Figure 28 - Debugging of Application in Debug Perspective The project building and execution facilities of RISC-V Studio are discussed in greater detail in subsequent chapters of this guide. Hopefully, this chapter illustrates just how easy it is to get a project up and running with RISC-V Studio!","title":"Debugging the Project"},{"location":"manual/Deleting-Project/","text":"Deleting a project is done by right clicking on the project and selecting \u201cDelete\u201d Once \u201cDelete\u201d is selected, RISC-V Studio\u2122 IDE presents a dialog that specifies whether or not everything in the project directory is to be deleted. If the contents are not deleted, they may be used in a subsequent creation of another project.","title":"Deleting Project"},{"location":"manual/Deleting-Workspace/","text":"Deleting a workspace in RISC-V Studio is done by simply deleting the sub-directory of the workspace. Doing so will also delete any projects contained within the workspace, since they are all maintained in a workspace-relative fashion.","title":"Deleting Workspace"},{"location":"manual/Deleting-a-File/","text":"Deleting a project file is easy; simply select the file and the \u201cDelete Key.\u201d This will bring the delete file dialog from which simply select \u201cYes\u201d to delete the file.","title":"Deleting a File"},{"location":"manual/Diagnostic-Options/","text":"These options, shown in Figure 54, let you generate extra reports about the executable, including memory usages, files crossed referenced, and one or more trace symbol(s). Figure 54 - Diagnostic Options","title":"Diagnostic Options"},{"location":"manual/Disassembly-Viewing/","text":"The disassembly view is opened by simply selecting the \u201cDisassembly\u201d tab, or Windows->Show Views->Disassembly:","title":"Disassembly Viewing"},{"location":"manual/Editing-an-Existing-File/","text":"Selecting a file to edit is easy; simply double click on the file name in the \u201cProject Explorer\u201d view. Once selected, the file is presented in the source view. Notice that comments are colored a light green, language keywords are colored magenta, and language statements are colored black. These color codings make it easier to write code in the C/C++ language. Editing is free-form, simply click on the desired location to edit and start typing.","title":"Editing an Existing File"},{"location":"manual/Errors-and-Warning-Settings/","text":"This dialog allows you to control various error and warning reporting aspect of the compiler, as shown below in Figure 49. Figure 49 - C Compiler Errors and Warnings Settings","title":"Errors and Warning Settings"},{"location":"manual/General-Options/","text":"Linker Settings \u00b6 The high-level overview of the current C Linker settings is shown below in Figure 50. Figure 50 - Linker High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the linker is going to be invoked for this project. All executables, by default, will be linked with these options. General Options \u00b6 The General Options allows you to control the heap and stack size, as well as to write in additional options not covered by the dialog. A view of the General Option dialog is shown below in Figure 51. Figure 51 - Linker General Options","title":"General Options"},{"location":"manual/General-Options/#linker-settings","text":"The high-level overview of the current C Linker settings is shown below in Figure 50. Figure 50 - Linker High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the linker is going to be invoked for this project. All executables, by default, will be linked with these options.","title":"Linker Settings"},{"location":"manual/General-Options/#general-options","text":"The General Options allows you to control the heap and stack size, as well as to write in additional options not covered by the dialog. A view of the General Option dialog is shown below in Figure 51. Figure 51 - Linker General Options","title":"General Options"},{"location":"manual/General-Settings/","text":"C Compiler Settings \u00b6 The high-level overview of the current C Compiler settings is shown below in Figure 47. Figure 47 - C Compiler High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the compiler is going to be invoked for this project. All files with a \u201c.c\u201d extension will be built, by default, with these options. General Settings \u00b6 The General settings dialog contains options enabling you to control various aspect of code and debug symbol generation by the compiler. You can also define additional pre-processor symbols, as well as include directory search path. An overview of the general setting dialog is shown below in Figure 48. Figure 48 - C Compiler General Settings","title":"General Settings"},{"location":"manual/General-Settings/#c-compiler-settings","text":"The high-level overview of the current C Compiler settings is shown below in Figure 47. Figure 47 - C Compiler High Level Overview The \u201cCommand\u201d and \u201cAll options\u201d entries show exactly how the compiler is going to be invoked for this project. All files with a \u201c.c\u201d extension will be built, by default, with these options.","title":"C Compiler Settings"},{"location":"manual/General-Settings/#general-settings","text":"The General settings dialog contains options enabling you to control various aspect of code and debug symbol generation by the compiler. You can also define additional pre-processor symbols, as well as include directory search path. An overview of the general setting dialog is shown below in Figure 48. Figure 48 - C Compiler General Settings","title":"General Settings"},{"location":"manual/Getting-Help/","text":"Getting Help \u00b6 For the latest product documentation, check the RISC-V Studio\u2122 IDE release page . In addition to this User Guide, there are general Eclipse information resources available from within the IDE. These can be found by selecting the \u201c Help -> Help Contents \u201d menu item: Workbench User Guide for general overview and usage of the Eclipse environment, and C/C++ Development User Guide for an overview of C/C++ support in Eclipse. As RISC-V Studio IDE is based on Eclipse & CDT, both links above are pertinent. Other aspects of the IDE specific to a variety of usability enhancement, and support for RISC-V are documented only in this user guide. Reporting Issues \u00b6 You can use the following link to report an issue, give suggestion for improvement, or share your experience: https://github.com/risc-v-studio-ide/Releases/issues/new . If you report an issue, please make sure that you provide: A detailed description of the problem, including frequency of occurrence and how it can be reliably reproduced. When possible and applicable, attach the project and/or files that cause the problem. The version of the RISC-V Studio IDE that you are using. You can get this information by selecting Help -> About RISC-V Studio . Giving Back \u00b6 RISC-V represents an exciting paradigm shift in how hardware and software products of varying degree of complexity will be made. If you do anything at all worth doing with RISC-V, you're bound to get stuck at some point. Should you find a way forward, either through help or information here or elsewhere, do take moment to give back and help share/post your experience so our team and others users who come after you can benefit from your epiphany.","title":"Getting Help"},{"location":"manual/Getting-Help/#getting-help","text":"For the latest product documentation, check the RISC-V Studio\u2122 IDE release page . In addition to this User Guide, there are general Eclipse information resources available from within the IDE. These can be found by selecting the \u201c Help -> Help Contents \u201d menu item: Workbench User Guide for general overview and usage of the Eclipse environment, and C/C++ Development User Guide for an overview of C/C++ support in Eclipse. As RISC-V Studio IDE is based on Eclipse & CDT, both links above are pertinent. Other aspects of the IDE specific to a variety of usability enhancement, and support for RISC-V are documented only in this user guide.","title":"Getting Help"},{"location":"manual/Getting-Help/#reporting-issues","text":"You can use the following link to report an issue, give suggestion for improvement, or share your experience: https://github.com/risc-v-studio-ide/Releases/issues/new . If you report an issue, please make sure that you provide: A detailed description of the problem, including frequency of occurrence and how it can be reliably reproduced. When possible and applicable, attach the project and/or files that cause the problem. The version of the RISC-V Studio IDE that you are using. You can get this information by selecting Help -> About RISC-V Studio .","title":"Reporting Issues"},{"location":"manual/Getting-Help/#giving-back","text":"RISC-V represents an exciting paradigm shift in how hardware and software products of varying degree of complexity will be made. If you do anything at all worth doing with RISC-V, you're bound to get stuck at some point. Should you find a way forward, either through help or information here or elsewhere, do take moment to give back and help share/post your experience so our team and others users who come after you can benefit from your epiphany.","title":"Giving Back"},{"location":"manual/Getting-Started/","text":"Run RISC-V Studio via the \u201cStart\u201d button or via the RISC-V Studio icon on the desktop: At this point you will observe the RISC-V Studio Workspace Launcher dialog. Select a directory on your host computer that RISC-V Studio can use to store projects and the workspace. Ensure that you have write permission for this directory. More on Eclipse projects and the workspace can be found in the Eclipse documentation: http://help.eclipse.org/kepler/index.jsp If you have selected a new workspace, RISC-V Studio will start at the welcome screen: Shows a quick overview of RISC-V Studio for RISC-V MCUs Shows the web resources available with RISC-V Studio for RISC-V MCUs. You can, for example, download versions of the RISC-V C compiler from this resource. Enter the RISC-V Studio workbench Note: In the next sessions, all example projects are introduced with assumption that the toolchain is riscv-rvdn-elf . If you want to use your own/custom toolchain, please refer to advanced topics on Using custom toolchain","title":"Getting Started"},{"location":"manual/Home/","text":"Welcome to the RISC-V Studio\u2122 IDE Wiki!","title":"Home"},{"location":"manual/Importing-Source-Files-Stand-Project/","text":"Importing files into newly created project is straightforward; simply drag and drop the desired files into the project. Files may also be imported to the project through menu selections. To explicitly import one or more files, \u201cright-click\u201d on the project as shown below and select the Import menu selection as shown in Figure 41. Figure 41 - Import Menu Selection Once Import is selected, RISC-V Studio\u2122 IDE displays the Import dialog, showing many options for the source of the files to import. Generally, the \u201cFile System\u201d option is the most used source for importing. Select this option to import one or more files from the file system into your project. The File System Import dialog is now displayed. Next, expand the \u201cGeneral\u201d folder, select \u201cFile System,\u201d and select the \u201cNext\u201d button. Simply use the Browse button to navigate to the specific folder containing the source files to import, select the files to import within that directory, and select \u201cFinish.\u201d You will now observe the selected files being imported into the selected project. At this point, all the necessary files for building an RISC-V Embedded Linux executable for RISC-V MCUs are contained in the project. Note that additional files might be required for executable projects and are specified in the linker settings dialogs. Such files include linker control files and the desired library files to be linked with the exec","title":"Importing Source Files Stand Project"},{"location":"manual/Importing-Source-Files/","text":"Importing files into the newly created project is straightforward; simply drag and drop the desired files into the project. Files may also be imported to the project through menu selections. To explicitly import one or more files, \u201cright-click\u201d on the project as shown and select the Import menu selection as shown in Figure 35. Figure 35 - Import Menu Selection Once Import is selected, RISC-V Studio\u2122 IDE displays the Import dialog, showing many options for the source of the files to import. Generally, the \u201cFile System\u201d option is the most used source for importing. The figure below shows the Import dialog, the File System selection and the mouse positioned on the \u201cNext\u201d button ready to proceed. The File System Import dialog is now displayed. Next, expand the \u201cGeneral\u201d folder, select \u201cFile System,\u201d and select the \u201cNext\u201d button. This results in the file browse dialog shown in Figure 36: Figure 36 - File Browser Dialog Simply use the Browse button to navigate to the specific folder containing the source files to import, select the files to import within that directory, and select \u201cFinish.\u201d This is show below in Figure 37. Figure 37 - File Import Dialog","title":"Importing Source Files"},{"location":"manual/Installing-host-tools/","text":"The IDE depends on tools from the host environment for its operation. When these tools are missing, you may encountered issues when using the IDE. An example of what happens when the program make is not available on the host is shown below: This issue can be resolved either by modifying the project settings to utilize Eclipse internal build mechanism (described elsewhere), or by installing the necessary tools on the host as follows: On Linux \u00b6 The make program and utilities needed build Ubuntu/Debian packages can be installed on an Ubuntu Linux host by, $ sudo apt-get install build-essential Upon completion, check if make is available: $ which make /usr/bin/make Finally, restart the IDE. On Windows \u00b6 The best option on Windows host is to download and install the MinGW's msys package here . After installation, start a command shell and check if make is available on your host: c:\\users\\admin> make Restart the IDE.","title":"Install Host Tools"},{"location":"manual/Installing-host-tools/#on-linux","text":"The make program and utilities needed build Ubuntu/Debian packages can be installed on an Ubuntu Linux host by, $ sudo apt-get install build-essential Upon completion, check if make is available: $ which make /usr/bin/make Finally, restart the IDE.","title":"On Linux"},{"location":"manual/Installing-host-tools/#on-windows","text":"The best option on Windows host is to download and install the MinGW's msys package here . After installation, start a command shell and check if make is available on your host: c:\\users\\admin> make Restart the IDE.","title":"On Windows"},{"location":"manual/Installing-risc-v-studio-on-Windows/","text":"We recommend that RISC-V Studio\u2122 IDE be installed in the default directory, which varies depending on the host computer Operating System. On Windows, RISC-V Studio\u2122 IDE is installed under: c: \\P rogram Files \\R ISC-V Studio Download latest IDE releases from https://github.com/RISC-V-studio-ide/Releases/releases RISC-V Studio\u2122 IDE utilizes izPack to manage the installation on the host machine. To install the IDE, run the executable installer by right-clicking on the executable from the desktop or file manager and select Run as administrator: The main RISC-V Studio\u2122 IDE installer screen is shown below. Select the \u201cNext\u201d button to proceed with the installation. The RISC-V Studio\u2122 IDE release note is shown below. Please read over to verify that the contents meet your expectation, and select the \u201cNext\u201d to proceed. The RISC-V Studio\u2122 IDE End User License Agreement will be provided. Select \u201cI accept the terms of this license agreement\u201d and \u201cNext\u201d to continue or \u201cQuit\u201d to exit. Once \u201cNext\u201d is selected, RISC-V Studio\u2122 IDE presents the packages to install. Select \u201cNext\u201d to proceed. Once \u201cNext\u201d is selected, RISC-V Studio\u2122 IDE installer presents the installation path below. Can keep the recommended installation path, or enter an alternative. Select \u201cNext\u201d to continue. If RISC-V Studio\u2122 IDE has previously been installed in the selected path, users will be asked whether or not to overwrite the existing installation. It is a good idea that users select an alternate path in this case. The RISC-V Studio\u2122 IDE installer presents a summary of packages to be installed in. Select \u201cNext\u201d to proceed. The installer shall begin to copy the selected packages into the installation directory, shown below. Can select Create shortcuts in the Start-Menu, Create additional shortcuts on the desktop. Create shortcut for current user or all users. Select \u201cNext\u201d to continue. Click the \u201cDone\u201d button to complete the installation of RISC-V Studio\u2122 IDE. The RISC-V Studio\u2122 IDE is now installed on host system.","title":"Installing RISC-V Studio"},{"location":"manual/Installing-risc-v-studio-on-linux/","text":"RISC-V Studio Install Flow \u00b6 Download latest IDE releases from https://github.com/RISC-V-studio-ide/Releases/releases Extract IDE, for example ls riscvstudio-1.0.48_linux.tar.bz2 Extract tar -xf riscvstudio-1.0.48_linux.tar.bz2 ls riscvstudio-1.0.48_linux.tar.bz2 RISCVStudioInstaller-1.0.48.run RISC-V Studio utilizes izPack to manage installation on the host machine. To install RISC-V Studio, run the executable installer, either from the command line, or by double-clicking on it from the desktop. ./RISCVStudioInstaller-1.0.48.run The main RISC-V Studio installer screen is shown below: Select the \u201c Next \u201d button to proceed with the installation. The RISC-V Studio release note is shown. Please read over to verify if the contents meet your expectation, and select the \u201c Next \u201d to proceed: Once \u201c Next \u201d is selected, you shall be presented with the RISC-V Studio End User License Agreement. Review this agreement carefully, select \u201cI accept the terms of this license agreement\u201d and \u201c Next \u201d to continue or \u201c Quit \u201d to exit. Once \u201c Next \u201d is selected, RISC-V Studio presents the packages to install. It is recommended that you simply select \u201c Next \u201d to proceed. Once \u201c Next \u201d is selected, RISC-V Studio installer presents the installation path. You can choose to keep the recommended installation path, or enter an alternative. Select \u201c Next \u201d to continue. If RISC-V Studio has previously been installed in the selected path, you will be asked whether or not to overwrite the existing installation as shown. It is strongly recommended that you select an alternate path in this case The RISC-V Studio installer presents a summary of packages to be installed. Simply select \u201c Next \u201d to proceed. Once \u201c Next \u201d is selected, RISC-V Studio shall begin to copy the selected packages into the installation directory. After all the RISC-V Studio files have been copied, one final dialog is presented below. Simply select the \u201c Done \u201d button to complete the installation of RISC-V Studio. You are now ready to use RISC-V Studio for RISC-V Processors!","title":"Installing RISC-V Studio"},{"location":"manual/Installing-risc-v-studio-on-linux/#risc-v-studio-install-flow","text":"Download latest IDE releases from https://github.com/RISC-V-studio-ide/Releases/releases Extract IDE, for example ls riscvstudio-1.0.48_linux.tar.bz2 Extract tar -xf riscvstudio-1.0.48_linux.tar.bz2 ls riscvstudio-1.0.48_linux.tar.bz2 RISCVStudioInstaller-1.0.48.run RISC-V Studio utilizes izPack to manage installation on the host machine. To install RISC-V Studio, run the executable installer, either from the command line, or by double-clicking on it from the desktop. ./RISCVStudioInstaller-1.0.48.run The main RISC-V Studio installer screen is shown below: Select the \u201c Next \u201d button to proceed with the installation. The RISC-V Studio release note is shown. Please read over to verify if the contents meet your expectation, and select the \u201c Next \u201d to proceed: Once \u201c Next \u201d is selected, you shall be presented with the RISC-V Studio End User License Agreement. Review this agreement carefully, select \u201cI accept the terms of this license agreement\u201d and \u201c Next \u201d to continue or \u201c Quit \u201d to exit. Once \u201c Next \u201d is selected, RISC-V Studio presents the packages to install. It is recommended that you simply select \u201c Next \u201d to proceed. Once \u201c Next \u201d is selected, RISC-V Studio installer presents the installation path. You can choose to keep the recommended installation path, or enter an alternative. Select \u201c Next \u201d to continue. If RISC-V Studio has previously been installed in the selected path, you will be asked whether or not to overwrite the existing installation as shown. It is strongly recommended that you select an alternate path in this case The RISC-V Studio installer presents a summary of packages to be installed. Simply select \u201c Next \u201d to proceed. Once \u201c Next \u201d is selected, RISC-V Studio shall begin to copy the selected packages into the installation directory. After all the RISC-V Studio files have been copied, one final dialog is presented below. Simply select the \u201c Done \u201d button to complete the installation of RISC-V Studio. You are now ready to use RISC-V Studio for RISC-V Processors!","title":"RISC-V Studio Install Flow"},{"location":"manual/Installing-supported-tools-on-Windows/","text":"There are number of supported tools need to be installed to use with RISC-V IDE. Quartus programmer tool RISC-V Toolchain USB Driver Quartus Prime Programmer and Tools \u00b6 Visit https://www.intel.com/content/www/us/en/collections/products/fpga/software/downloads.html?s=Newest and download Quartus ( Lite version) For example QuartusProgrammerSetup-21.1.0.842-windows.exe Install Quartus Programmer tool, select the target folder for installation On the Finish installation dialog, uncheck all options but keep Launch USB Blaster II driver installation to install driver for USB Blaster In some cases, user also need to install USB Blaster Driver as instruction from Terasic . This is detail instruction on Windows 10 Plug the USB-Blaster into your PC. Open Device Manager Right click to USB Blaster and Select Update Driver Select \" Browse my computer for drivers Update Environment variables: RISC-V Studio need to find Quartus Programmer tool to flash images to boards. It's needed to add Installed Quartus Programmer Tools to the Environment Variables RISC-V Toolchain \u00b6 Download latest release toolchain from https://github.com/RISC-V-studio-ide/Releases/releases Extract the downloaded file Update Environment Variables Install USB drivers \u00b6 Download zadig . After the installation is complete, open zadig, click Options-> in the zadig interface List All Devices, as follows. If you are using Usb blaster for debugging Select USB-Blaster and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. If you are using Bus blaster for debugging Select BUSBLASTERv3c and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. (Install for both Interface 0 and Interface 1)","title":"Installing supported tools"},{"location":"manual/Installing-supported-tools-on-Windows/#quartus-prime-programmer-and-tools","text":"Visit https://www.intel.com/content/www/us/en/collections/products/fpga/software/downloads.html?s=Newest and download Quartus ( Lite version) For example QuartusProgrammerSetup-21.1.0.842-windows.exe Install Quartus Programmer tool, select the target folder for installation On the Finish installation dialog, uncheck all options but keep Launch USB Blaster II driver installation to install driver for USB Blaster In some cases, user also need to install USB Blaster Driver as instruction from Terasic . This is detail instruction on Windows 10 Plug the USB-Blaster into your PC. Open Device Manager Right click to USB Blaster and Select Update Driver Select \" Browse my computer for drivers Update Environment variables: RISC-V Studio need to find Quartus Programmer tool to flash images to boards. It's needed to add Installed Quartus Programmer Tools to the Environment Variables","title":"Quartus Prime Programmer and Tools"},{"location":"manual/Installing-supported-tools-on-Windows/#risc-v-toolchain","text":"Download latest release toolchain from https://github.com/RISC-V-studio-ide/Releases/releases Extract the downloaded file Update Environment Variables","title":"RISC-V Toolchain"},{"location":"manual/Installing-supported-tools-on-Windows/#install-usb-drivers","text":"Download zadig . After the installation is complete, open zadig, click Options-> in the zadig interface List All Devices, as follows. If you are using Usb blaster for debugging Select USB-Blaster and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. If you are using Bus blaster for debugging Select BUSBLASTERv3c and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. (Install for both Interface 0 and Interface 1)","title":"Install USB drivers"},{"location":"manual/Installing-supported-tools-on-linux/","text":"There are number of supported tools need to be installed to use with RISC-V IDE. Quartus RISC-V Toolchain Quartus \u00b6 Visit https://www.intel.com/content/www/us/en/collections/products/fpga/software/downloads.html?s=Newest and download Quartus ( Lite version) For example, Quartus-lite-21.1.0.842-linux.tar Install tools Update PATH to /etc/environment # Update QUARTUS_TOOL to your installation directory, for example # /home/administrator/intelFPGA_lite/18.1/quartus QUARTUS_TOOL = PATH = $PATH : $QUARTUS_TOOL /bin RISC-V Toolchain \u00b6 1. Toolchain from RISC-V Studio \u00b6 Download latest release toolchain from https://github.com/RISC-V-studio-ide/Releases/releases Extract toolchain tar -xf riscv-rvdn-elf.tar.bz2 ls riscv-rvdn-elf riscv-rvdn-elf.tar.bz2 Set toolchain to PATH system. Add the following lines to your /etc/environment Note: Please update the path to toolchain (path to riscv-rvdn-elf directory) to match with your machine RISCV_RVDN_ELF_TC= PATH=$PATH:$QUARTUS_TOOL/bin:$RISCV_RVDN_ELF_TC/bin","title":"Installing supported tools"},{"location":"manual/Installing-supported-tools-on-linux/#quartus","text":"Visit https://www.intel.com/content/www/us/en/collections/products/fpga/software/downloads.html?s=Newest and download Quartus ( Lite version) For example, Quartus-lite-21.1.0.842-linux.tar Install tools Update PATH to /etc/environment # Update QUARTUS_TOOL to your installation directory, for example # /home/administrator/intelFPGA_lite/18.1/quartus QUARTUS_TOOL = PATH = $PATH : $QUARTUS_TOOL /bin","title":"Quartus"},{"location":"manual/Installing-supported-tools-on-linux/#risc-v-toolchain","text":"","title":"RISC-V Toolchain"},{"location":"manual/Installing-supported-tools-on-linux/#1-toolchain-from-risc-v-studio","text":"Download latest release toolchain from https://github.com/RISC-V-studio-ide/Releases/releases Extract toolchain tar -xf riscv-rvdn-elf.tar.bz2 ls riscv-rvdn-elf riscv-rvdn-elf.tar.bz2 Set toolchain to PATH system. Add the following lines to your /etc/environment Note: Please update the path to toolchain (path to riscv-rvdn-elf directory) to match with your machine RISCV_RVDN_ELF_TC= PATH=$PATH:$QUARTUS_TOOL/bin:$RISCV_RVDN_ELF_TC/bin","title":"1. Toolchain from RISC-V Studio"},{"location":"manual/Launching-The-New-Connection/","text":"Launching an existing connection is very simple; just click on the Debug button as shown below: At this point the connection is ready for execution and debugging of the specified executable image.","title":"Launching The New Connection"},{"location":"manual/Libraries-Options/","text":"These options, shown in Figure 53, let you specify one or more standard libraries to link with the project executable. In the event that one or more libraries are not part of the RISC-V toolchain (i.e. they reside in a different directory), you can also specify one or more search paths for the libraries. Other options include the ability to exclude standard libraries, start-up code, or floating point library. Note that the selections in the Libraries dialog specify the \u201cc\u201d and \u201cgcc\u201d libraries. It is the GNU linker than then prepends the \u201clib\u201d modifier to the library names specified and thus expects to find \u201clibc.a\u201d and \u201clibgcc.a\u201d library files in one of the specified library paths. RISC-V Studio\u2122 IDE also makes it possible to specify the path and actual name of library files. The \u201cAdditional Inputs ( .o/ .lib)\u201d dialog is used to do this. Please note that references to actual path on your host computer will make your project/workspace not portable to other host systems. Figure 53 - Library Options","title":"Libraries Options"},{"location":"manual/Memory-Viewing/","text":"The target memory is easily viewed; simply select the \u201cMemory\u201d tab, or Windows->Show Views->Memory: Once selected, the \u201cMemory\u201d window (Empty) is displayed: To add an address to display in the \u201cMemory\u201d view, simply click the plus icon to bring up the address dialog: Entering \u201c&InitApp\u201d causes the address of this variable in the demonstration system to be displayed","title":"Memory Viewing"},{"location":"manual/Modifying-Projects/","text":"There are many build options available for RISC-V Studio\u2122 IDE for RISC-V MCUs developers. The options are available through the Properties dialog. To bring up the Properties dialog, right click on the project name and then select \u201cProperties,\u201d as shown below in Figure 44. Figure 44 - Project Properties Selection Selecting \u201cProperties\u201d results in RISC-V Studio\u2122 IDE bringing up the Properties dialog. This dialog has many configuration options, however, the most typically used options are found within the \u201cC/C++ Build -> Settings\u201d selection, shown here in Figure 45. Figure 45 - C/C++ Build / Settings Selection","title":"Modifying Projects"},{"location":"manual/Optimization-Settings/","text":"The optimization settings dialog allows you to change the optimization level of code generated by the compiler. Note that you will need to upgrade to a paid version of the compiler in order to access the full optimization settings of the compiler.","title":"Optimization Settings"},{"location":"manual/Other-Options/","text":"The Other options let you tune various parameters of the assembler, as shown in Figure 57. Figure 57 - Assembler Other Options","title":"Other Options"},{"location":"manual/Overview/","text":"RISC-V Studio is an integrated dev/ops environment that streamlines the development of software and platforms utilizing the RISC-V ISA. The IDE runs on 64-bit Windows and Linux hosts, and supports standalone embedded applications and popular RTOSes. In both cases, QEMU is the default target platform. Support for other RISC-V targets including emulator, cycle-accurate simulator, FPGA, and RISC-V ASIC are also available. The target and debug components that sit between the IDE front-end and the target platform provide abstractions that enable external open-source and commercial run-time environments and hardware debug tools to be integrated through addins. The interfaces to these components are currently out of scope of this User Guide.","title":"Overview"},{"location":"manual/Program-Code-Viewing/","text":"Viewing program source code in RISC-V Studio\u2122 IDE is easy; simply double-click on the file to view in the \u201cProject Explorer\u201d dialog. Doing so opens the source viewing window with the contents of the selected file","title":"Program Code Viewing"},{"location":"manual/Program-Control/","text":"RISC-V Studio\u2122 IDE automatically places a breakpoint and launches the downloaded image, if the \u201cStop in main\u201d option is selected under the \u201cDebugger\u201d tab. If this is not selected, RISC-V Studio\u2122 IDE simply positions the program counter at the program entry point, which in GNU-built executable is at the label _start.","title":"Program Control"},{"location":"manual/Program-Download/","text":"The processing for making a target connection automatically program the executable unless the \u201cConnect Only\u201d option under the \u201cDebugger\u201d tab is selected. If not selected, establishing a connection will perform all initialization on the target and then download the executable image. The image downloaded can also be verified (read back and compared) to make sure the download was successful. This is accomplished by selecting the \u201cVerify downloaded image\u201d option under the \u201cDebugger\u201d tab. If the verification fails, it is likely that the image is being loaded to an invalid memory address or the board initialization is incorrect.","title":"Program Download"},{"location":"manual/Program-Viewing/","text":"RISC-V Studio\u2122 IDE provides extensive viewing capabilities into the target program, including views of source, disassembly, variables, registers, memory, and ThreadX objects. The following sections describe each of these RISC-V Studio\u2122 IDE views.","title":"Program Viewing"},{"location":"manual/Register-Viewing/","text":"The target processor registers are also available for viewing, simply select the \u201cRegisters\u201d tab, or Windows->Show Views->Registers: Once selected, the \u201cRegisters\u201d window is displayed. By default, the RISC-V MCU registers are shown in the \u201cRegisters\u201d window displayed in decimal format. Clicking on the register shows its value in different formats:","title":"Register Viewing"},{"location":"manual/Requirements-Constraints/","text":"Host Requirements \u00b6 RISC-V Studio supports Linux and Windows hosts, and has been tested on Linux 64-bit system (Ubuntu 18.04, Ubuntu 20.04) and Windows 64-bit system (Windows 10 64-bit). A minimum of 2GB of RAM, 20 GB of available hard-disk space is required. For optimal performance, more CPU cores, memory, and disk-space are recommended. Disclaimer \u00b6 As with any IDE, RISC-V Studio is a tool that automate what you're meant to do manually, which includes selecting and building a RISC-V system, cross compiling the embedded application, downloading and running the application image, and utimately debugging and monitoring its execution. That said, you still have to know what you're doing. The IDE doesn't fetch coffee, find bugs, or generate perfect code for you. Not yet anyway ... Also, since RISC-V Studio is integrated and enhanced with Eclipse plugins, it may likewise be constrained by their limitations, or afficted by their defects.","title":"Requirements & Constraints"},{"location":"manual/Requirements-Constraints/#host-requirements","text":"RISC-V Studio supports Linux and Windows hosts, and has been tested on Linux 64-bit system (Ubuntu 18.04, Ubuntu 20.04) and Windows 64-bit system (Windows 10 64-bit). A minimum of 2GB of RAM, 20 GB of available hard-disk space is required. For optimal performance, more CPU cores, memory, and disk-space are recommended.","title":"Host Requirements"},{"location":"manual/Requirements-Constraints/#disclaimer","text":"As with any IDE, RISC-V Studio is a tool that automate what you're meant to do manually, which includes selecting and building a RISC-V system, cross compiling the embedded application, downloading and running the application image, and utimately debugging and monitoring its execution. That said, you still have to know what you're doing. The IDE doesn't fetch coffee, find bugs, or generate perfect code for you. Not yet anyway ... Also, since RISC-V Studio is integrated and enhanced with Eclipse plugins, it may likewise be constrained by their limitations, or afficted by their defects.","title":"Disclaimer"},{"location":"manual/Resume/","text":"Execution of a suspended (or just downloaded) program is resumed via the \u201cResume\u201d button in the Debug dialog: Once selected, the RISC-V Studio\u2122 IDE debugger shows the system running. The program is easily halted via the \u201cSuspend\u201d button: Once selected, the RISC-V Studio\u2122 IDE debugger shows where the system was halted. The program is easily resumed again via the \u201cResume\u201d button.","title":"Resume"},{"location":"manual/Runtime-Environment/","text":"Runtime Environment \u00b6 The IDE uses RISC-V QEMU as a default target to host standalone embedded and Linux applications. Standalone applications \u00b6 At debug time, the IDE spawns an instance of RISC-V QEMU to host the standalone applications. At present, file and console IOs are not yet being fielded and handled through the IDE semi-hosting capability. This feature will be supported in future releases. Linux applications \u00b6 Comming soon","title":"Runtime Environment"},{"location":"manual/Runtime-Environment/#runtime-environment","text":"The IDE uses RISC-V QEMU as a default target to host standalone embedded and Linux applications.","title":"Runtime Environment"},{"location":"manual/Runtime-Environment/#standalone-applications","text":"At debug time, the IDE spawns an instance of RISC-V QEMU to host the standalone applications. At present, file and console IOs are not yet being fielded and handled through the IDE semi-hosting capability. This feature will be supported in future releases.","title":"Standalone applications"},{"location":"manual/Runtime-Environment/#linux-applications","text":"Comming soon","title":"Linux applications"},{"location":"manual/Saving-Changes/","text":"Saving editing changes to a file is done simply by clicking on the \u201cSave\u201d button. The corresponding project can then be rebuilt to incorporate the latest source code changes. If changes are being made during execution and debug, it is important to rebuild the image and download it again in order for the RISC-V Studio debugger to accurately perform source level debugging.","title":"Saving Changes"},{"location":"manual/Single-Step-Into/","text":"Single-stepping allows the developer to execute one statement of code at a time. If a function call is present, selecting the \u201cStep Into\u201d button will step into the function call.","title":"Single Step Into"},{"location":"manual/Single-Step-Mode/","text":"RISC-V Studio\u2122 IDE supports single-stepping by assembly instruction or by C source level statements. The type of single stepping is determined by the \u201cInstruction Stepping Mode\u201d button. By default, the stepping mode is for stepping C source level statements; selecting this button will toggle the mode to assembly level stepping. Another selection of this button will change the mode back to C source level statement stepping.","title":"Single-Step Mode"},{"location":"manual/Single-Step-Over/","text":"The \u201cStep Over\u201d button, operates in the same way as the \u201cStep Into\u201d button except when a function call is present. Instead of stepping into the called function, the \u201cStep Over\u201d button steps to the statement following the called function, i.e., \u201cover the function.\u201d Once selected, the \u201cStep Over\u201d button will cause the program to run to the next instruction after the function call.","title":"Single-Step-Over"},{"location":"manual/Step-Return/","text":"When selected, the \u201cStep Return\u201d button, steps back to the caller of the current function. Selecting the \u201cStep Return\u201d button causes the program to return to the caller.","title":"Step Return"},{"location":"manual/Symbols-and-Macros/","text":"This option group lets you introduce additional linker symbols, as well as pre-processor macro definition used during the linking process, as shown in Figure 52. Figure 52 - Symbols and Macros Settings","title":"Symbols and Macros"},{"location":"manual/Terminating-a-Connection/","text":"When execution and debug of an image is complete and the connection is no longer needed, terminating a connection is very simple; just click on the \u201cTerminate and Remove\u201d button:","title":"Terminating a Connection"},{"location":"manual/Use-custom-toolchain/","text":"The IDE has been tested with default toolchain from https://github.com/RISC-V-studio-ide/Releases/releases . The 3 rd /custom toolchains are supported but have not been well tested yet. As Disclaimer : RISC-V Studio is a tool that automate what you're meant to do manually, which includes selecting and building a RISC-V system, cross compiling the embedded application, downloading and running the application image, and utimately debugging and monitoring its execution. That said, you still have to know what you're doing. The IDE doesn't fetch coffee, find bugs, or generate perfect code for you. Not yet anyway ... The following instruction shows how to use Xpack riscv toolchain as an example of using custom riscv toolchain. 1. Download and install custom toolchain \u00b6 The full instruction to install toolchain can be seen at Xpack RISC-V official site , please refer to the site for more detail. The following section summaries main steps on installing toolchain on Windows host. Download xPack toolchain from https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/ Extracted toolchain to target location Add new toolchain to environment variables 2. Create and debug project using QEMU and custom toolchain \u00b6 Create new project, select RISC-V Cross GCC as toolchain Select toolchain and toolchain path Build project Create QEMU debug configuration On Debugger tab, select QEMU On Debugger tab, select GDB command location On Debugger tab, QEMU option Emulation mode: Full System CPU: rv32 Machine: sifive_e Click apply and debug User should see the debug screen as","title":"Use custom toolchain"},{"location":"manual/Use-custom-toolchain/#1-download-and-install-custom-toolchain","text":"The full instruction to install toolchain can be seen at Xpack RISC-V official site , please refer to the site for more detail. The following section summaries main steps on installing toolchain on Windows host. Download xPack toolchain from https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/ Extracted toolchain to target location Add new toolchain to environment variables","title":"1. Download and install custom toolchain"},{"location":"manual/Use-custom-toolchain/#2-create-and-debug-project-using-qemu-and-custom-toolchain","text":"Create new project, select RISC-V Cross GCC as toolchain Select toolchain and toolchain path Build project Create QEMU debug configuration On Debugger tab, select QEMU On Debugger tab, select GDB command location On Debugger tab, QEMU option Emulation mode: Full System CPU: rv32 Machine: sifive_e Click apply and debug User should see the debug screen as","title":"2. Create and debug project using QEMU and custom toolchain"},{"location":"manual/Variable-Viewing/","text":"Viewing variables in RISC-V Studio\u2122 IDE is easy; simply select the Windows->Show Views->Variables:","title":"Variable Viewing"},{"location":"manual/Welcome/","text":"Thank you for choosing the RISC-V Studio\u2122 IDE","title":"Welcome"},{"location":"manual/What-is-a-workspace/","text":"RISC-V Studio workspace is effectively a sub-directory that contains one or more RISC-V Studio projects. RISC-V Studio workspaces are fully compatible with Eclipse workspaces, meaning that a workspace created by RISC-V Studio can be opened and viewed by a compatible Eclipse IDE. A workspace can contain one or more project(s).","title":"About Workspace"},{"location":"manual/_Footer/","text":"Copyright\u00a9 2021. SoC.one","title":" Footer"},{"location":"manual/_Sidebar/","text":"Before you start \u00b6 About This Guide Getting Help Introduction \u00b6 About the IDE Requirements & Constraints Overview Installation \u00b6 Installing on Windows Installing on Linux Install Host Tools Simple Example Project \u00b6 Getting Started Creating a Project Building the Project Debugging the Project Perspective \u00b6 C/C++ Perspective Debug Perspective Workspace \u00b6 About Workspace Creating Workspace Deleting Workspace Projects \u00b6 RISC-V freeRTOS Project \u00b6 Creating Project Building the Executable Debug with hardware RISC-V Embedded Linux Project \u00b6 Creating Project Creating Source Files Importing Source Files Building the Executable RISC-V Standalone Embedded Project \u00b6 Creating Project Creating Source Files Importing Source Files Building the Executable Closing Project Modifying Projects Deleting Project RISC-V C Compiler Settings \u00b6 General Settings Errors and Warning Settings Optimization Settings RISC-V Linker Settings \u00b6 General Options Symbols and Macros Libraries Options Diagnostic Options RISC-V Assembler Settings \u00b6 General Settings Other Options Creating & Editing Files \u00b6 Creating a New File Deleting a File Editing an Existing File Saving Changes Running & Debugging \u00b6 Runtime Environment Debug Configurations Launching The New Connection Terminating a Connection Program Download Program Control Resume Breakpoint Single-Step Mode Single Step Into Single-Step-Over Step Return Program Viewing Program Code Viewing Disassembly Viewing Variable Viewing Register Viewing Memory Viewing","title":"Before you start"},{"location":"manual/_Sidebar/#before-you-start","text":"About This Guide Getting Help","title":"Before you start"},{"location":"manual/_Sidebar/#introduction","text":"About the IDE Requirements & Constraints Overview","title":"Introduction"},{"location":"manual/_Sidebar/#installation","text":"Installing on Windows Installing on Linux Install Host Tools","title":"Installation"},{"location":"manual/_Sidebar/#simple-example-project","text":"Getting Started Creating a Project Building the Project Debugging the Project","title":"Simple Example Project"},{"location":"manual/_Sidebar/#perspective","text":"C/C++ Perspective Debug Perspective","title":"Perspective"},{"location":"manual/_Sidebar/#workspace","text":"About Workspace Creating Workspace Deleting Workspace","title":"Workspace"},{"location":"manual/_Sidebar/#projects","text":"","title":"Projects"},{"location":"manual/_Sidebar/#risc-v-freertos-project","text":"Creating Project Building the Executable Debug with hardware","title":"RISC-V freeRTOS Project"},{"location":"manual/_Sidebar/#risc-v-embedded-linux-project","text":"Creating Project Creating Source Files Importing Source Files Building the Executable","title":"RISC-V Embedded Linux Project"},{"location":"manual/_Sidebar/#risc-v-standalone-embedded-project","text":"Creating Project Creating Source Files Importing Source Files Building the Executable Closing Project Modifying Projects Deleting Project","title":"RISC-V Standalone Embedded Project"},{"location":"manual/_Sidebar/#risc-v-c-compiler-settings","text":"General Settings Errors and Warning Settings Optimization Settings","title":"RISC-V C Compiler Settings"},{"location":"manual/_Sidebar/#risc-v-linker-settings","text":"General Options Symbols and Macros Libraries Options Diagnostic Options","title":"RISC-V Linker Settings"},{"location":"manual/_Sidebar/#risc-v-assembler-settings","text":"General Settings Other Options","title":"RISC-V Assembler Settings"},{"location":"manual/_Sidebar/#creating-editing-files","text":"Creating a New File Deleting a File Editing an Existing File Saving Changes","title":"Creating &amp; Editing Files"},{"location":"manual/_Sidebar/#running-debugging","text":"Runtime Environment Debug Configurations Launching The New Connection Terminating a Connection Program Download Program Control Resume Breakpoint Single-Step Mode Single Step Into Single-Step-Over Step Return Program Viewing Program Code Viewing Disassembly Viewing Variable Viewing Register Viewing Memory Viewing","title":"Running &amp; Debugging"},{"location":"manual/pipenv/","text":"Start with pipenv \u00b6 pipenv \u00b6 Pipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. pypa/pipenv: Python Development Workflow for Humans. Install all packages \u00b6 pipenv sync --dev # Installs all packages specified in Pipfile.lock. Run MkDocs \u00b6 pipenv shell # Spawns a shell within the virtualenv. mkdocs serve Or, run mkdocs with pipenv run pipenv run mkdocs serve pipenv run \u00b6 pipenv task are also defined by Pipfile pipenv run version # mkdocs --version pipenv run help # mkdocs --help pipenv run inv serve # inv serve pipenv run serve # mkdocs serve pipenv run build # mkdocs build pipenv run deploy # mkdocs gh-deploy","title":"Start with pipenv"},{"location":"manual/pipenv/#start-with-pipenv","text":"","title":"Start with pipenv"},{"location":"manual/pipenv/#pipenv","text":"Pipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. pypa/pipenv: Python Development Workflow for Humans.","title":"pipenv"},{"location":"manual/pipenv/#install-all-packages","text":"pipenv sync --dev # Installs all packages specified in Pipfile.lock.","title":"Install all packages"},{"location":"manual/pipenv/#run-mkdocs","text":"pipenv shell # Spawns a shell within the virtualenv. mkdocs serve Or, run mkdocs with pipenv run pipenv run mkdocs serve","title":"Run MkDocs"},{"location":"manual/pipenv/#pipenv-run","text":"pipenv task are also defined by Pipfile pipenv run version # mkdocs --version pipenv run help # mkdocs --help pipenv run inv serve # inv serve pipenv run serve # mkdocs serve pipenv run build # mkdocs build pipenv run deploy # mkdocs gh-deploy","title":"pipenv run"},{"location":"manual/common-errors/jtag-debug/","text":"1. Error: libusb_open() failed \u00b6 The reason for this error is that the device has not been found. The solution as: Check whether the hardware connection is correct The pins that need to be connected for JTAG debugging are TMS, TCK, TDI and TDO. Make sure they are connected to the JTAG debugger module (Bus blaster,...) Check whether the driver for JTAG debugging is correct. If the hardware connection is completely correct, it means that the driver is not installed/setup correctly. On Linux \u00b6 User need to setup udev rules correctly with the JTAG debugger On the Linux environment, the following rules need to be added to the file /etc/udev/rules.d/51-usbblaster.rules to allow the USB devices are recognized and be accessed by the IDE Note: The vendor ID and Product ID can be obtained using lsusb command # USB-Blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6001\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6002\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6003\" , MODE = \"0666\" , GROUP = \"plugdev\" # USB-Blaster II SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6010\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6810\" , MODE = \"0666\" , GROUP = \"plugdev\" # Bus blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"0403\" , ATTR { idProduct }== \"7780\" , MODE = \"0666\" , GROUP = \"plugdev\" Replug the USB cables from the PC to take effect. On Windows \u00b6 User need to install the correct driver Download zadig . After the installation is complete, open zadig, click Options-> in the zadig interface List All Devices, as follows. If you are using Usb blaster for debugging Select USB-Blaster and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. If you are using Bus blaster for debugging Select BUSBLASTERv3c and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. (Install for both Interface 0 and Interface 1) After the hardware and software issues are fixed, you will be able to debug the app as The important messages that show the JTAG debug work fine is Info : Examined RISC-V core; found 1 harts Info : hart 0: XLEN=32, misa=0x40801104 [neorv32.cpu.0] Target successfully examined. 2. OpenOCD get confused on which JTAG port to use \u00b6 Open On-Chip Debugger 0 .11.0+dev-02215-gcc0ecfb6d ( 2022 -01-25-04:45 ) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html Info : only one transport option ; autoselect 'jtag' Warn : Transport \"jtag\" was already selected 1 Info : Listening on port 5555 for tcl connections Info : Listening on port 4444 for telnet connections Info : No lowlevel driver configured, using ftdi Info : usb blaster interface using libftdi Info : This adapter doesn 't support configurable speed Info : JTAG tap: neorv32.cpu tap/device found: 0x031050dd (mfg: 0x06e (Altera), part: 0x3105, ver: 0x0) Warn : JTAG tap: neorv32.cpu UNEXPECTED: 0x031050dd (mfg: 0x06e (Altera), part: 0x3105, ver: 0x0) Error: JTAG tap: neorv32.cpu expected 1 of 1: 0x0cafe001 (mfg: 0x000 (<invalid>), part: 0xcafe, ver: 0x0) Error: Trying to use configured scan chain anyway... Error: IR capture error at bit 5, saw 0x55 not 0x...3 Warn : Bypassing JTAG setup events due to errors Error: dtmcontrol is 0. Check JTAG connectivity/board power. Warn : target neorv32.cpu.0 examination failed Error: dtmcontrol is 0. Check JTAG connectivity/board power. Error: dtmcontrol is 0. Check JTAG connectivity/board power. Info : starting gdb server for neorv32.cpu.0 on 3333 Info : Listening on port 3333 for gdb connections Error: dtmcontrol is 0. Check JTAG connectivity/board power. Info : accepting ' gdb ' connection on tcp/3333 Error: Target not examined yet Error executing event gdb-attach on target neorv32.cpu.0: Error: Target neorv32.cpu.0 not examined yet, refuse gdb connection 1! Error: attempted ' gdb ' connection rejected shutdown command invoked This error happen when debuging the app on DE10-Lite with Altera USB Blaster JTAG Debugger. The onboard JTAG has the same vendor ID and Product ID with Altera USB Blaster JTAG debugger. Solutions: - The temporal workaround is + unplug all cables from the PC + plug the onboard JTAG cable to the PC , wait a few seconds + Reflash the RISC-V Image to the board + Plug Altera USB Blaster JTAG debugger to the PC","title":"USB Blaster/Bus Blaster for JTAG debugging"},{"location":"manual/common-errors/jtag-debug/#1-error-libusb_open-failed","text":"The reason for this error is that the device has not been found. The solution as: Check whether the hardware connection is correct The pins that need to be connected for JTAG debugging are TMS, TCK, TDI and TDO. Make sure they are connected to the JTAG debugger module (Bus blaster,...) Check whether the driver for JTAG debugging is correct. If the hardware connection is completely correct, it means that the driver is not installed/setup correctly.","title":"1. Error: libusb_open() failed"},{"location":"manual/common-errors/jtag-debug/#on-linux","text":"User need to setup udev rules correctly with the JTAG debugger On the Linux environment, the following rules need to be added to the file /etc/udev/rules.d/51-usbblaster.rules to allow the USB devices are recognized and be accessed by the IDE Note: The vendor ID and Product ID can be obtained using lsusb command # USB-Blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6001\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6002\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6003\" , MODE = \"0666\" , GROUP = \"plugdev\" # USB-Blaster II SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6010\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6810\" , MODE = \"0666\" , GROUP = \"plugdev\" # Bus blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"0403\" , ATTR { idProduct }== \"7780\" , MODE = \"0666\" , GROUP = \"plugdev\" Replug the USB cables from the PC to take effect.","title":"On Linux"},{"location":"manual/common-errors/jtag-debug/#on-windows","text":"User need to install the correct driver Download zadig . After the installation is complete, open zadig, click Options-> in the zadig interface List All Devices, as follows. If you are using Usb blaster for debugging Select USB-Blaster and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. If you are using Bus blaster for debugging Select BUSBLASTERv3c and click Install Driver or Replace Driver(if you have a similar drive, it will display the same as the figure below Replace Driver), as follows. (Install for both Interface 0 and Interface 1) After the hardware and software issues are fixed, you will be able to debug the app as The important messages that show the JTAG debug work fine is Info : Examined RISC-V core; found 1 harts Info : hart 0: XLEN=32, misa=0x40801104 [neorv32.cpu.0] Target successfully examined.","title":"On Windows"},{"location":"manual/common-errors/jtag-debug/#2-openocd-get-confused-on-which-jtag-port-to-use","text":"Open On-Chip Debugger 0 .11.0+dev-02215-gcc0ecfb6d ( 2022 -01-25-04:45 ) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html Info : only one transport option ; autoselect 'jtag' Warn : Transport \"jtag\" was already selected 1 Info : Listening on port 5555 for tcl connections Info : Listening on port 4444 for telnet connections Info : No lowlevel driver configured, using ftdi Info : usb blaster interface using libftdi Info : This adapter doesn 't support configurable speed Info : JTAG tap: neorv32.cpu tap/device found: 0x031050dd (mfg: 0x06e (Altera), part: 0x3105, ver: 0x0) Warn : JTAG tap: neorv32.cpu UNEXPECTED: 0x031050dd (mfg: 0x06e (Altera), part: 0x3105, ver: 0x0) Error: JTAG tap: neorv32.cpu expected 1 of 1: 0x0cafe001 (mfg: 0x000 (<invalid>), part: 0xcafe, ver: 0x0) Error: Trying to use configured scan chain anyway... Error: IR capture error at bit 5, saw 0x55 not 0x...3 Warn : Bypassing JTAG setup events due to errors Error: dtmcontrol is 0. Check JTAG connectivity/board power. Warn : target neorv32.cpu.0 examination failed Error: dtmcontrol is 0. Check JTAG connectivity/board power. Error: dtmcontrol is 0. Check JTAG connectivity/board power. Info : starting gdb server for neorv32.cpu.0 on 3333 Info : Listening on port 3333 for gdb connections Error: dtmcontrol is 0. Check JTAG connectivity/board power. Info : accepting ' gdb ' connection on tcp/3333 Error: Target not examined yet Error executing event gdb-attach on target neorv32.cpu.0: Error: Target neorv32.cpu.0 not examined yet, refuse gdb connection 1! Error: attempted ' gdb ' connection rejected shutdown command invoked This error happen when debuging the app on DE10-Lite with Altera USB Blaster JTAG Debugger. The onboard JTAG has the same vendor ID and Product ID with Altera USB Blaster JTAG debugger. Solutions: - The temporal workaround is + unplug all cables from the PC + plug the onboard JTAG cable to the PC , wait a few seconds + Reflash the RISC-V Image to the board + Plug Altera USB Blaster JTAG debugger to the PC","title":"2. OpenOCD get confused on which JTAG port to use"},{"location":"manual/common-errors/missing-toolchain/","text":"Missing toolchain \u00b6 The reason for this error is that the toolchain has not been found. The solution as install toolchain and update environment variables as the Installation sessions: On Windows On Linux","title":"Missing toolchain"},{"location":"manual/common-errors/missing-toolchain/#missing-toolchain","text":"The reason for this error is that the toolchain has not been found. The solution as install toolchain and update environment variables as the Installation sessions: On Windows On Linux","title":"Missing toolchain"},{"location":"manual/hardware/custom-openocd-configuration/","text":"OpenOCD Configuration \u00b6 When debug RISC-V on the real hardware, user can use custom OpenOCD configration for number of reasons: Use different JTAG debugger adapater Add/Change default OpenOCD configration etc.. To do so, on the hardware debug configuration, select OpenOCD file","title":"Use custom openocd"},{"location":"manual/hardware/custom-openocd-configuration/#openocd-configuration","text":"When debug RISC-V on the real hardware, user can use custom OpenOCD configration for number of reasons: Use different JTAG debugger adapater Add/Change default OpenOCD configration etc.. To do so, on the hardware debug configuration, select OpenOCD file","title":"OpenOCD Configuration"},{"location":"manual/hardware/de10-lite/","text":"Altera DE10 Lite \u00b6 The following board and JTAG Debugger have been tested with RISC-V Studio FPGA Board: DE10-Lite JTAG Debugger: USB Bus Blaster JTAG Debugger is connected to FPGA board via extension IO header as in the following picture On the Linux environment, the following rules need to be added to the file /etc/udev/rules.d/51-usbblaster.rules to allow the USB devices are recognized and be accessed by the IDE Note: The vendor ID and Product ID can be obtained using lsusb command # USB-Blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6001\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6002\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6003\" , MODE = \"0666\" , GROUP = \"plugdev\" # USB-Blaster II SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6010\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6810\" , MODE = \"0666\" , GROUP = \"plugdev\" Replug the USB cables from the PC to take effect. OpenOCD reference configuration \u00b6 The following OpenOCD configuration is used to debug RISC-V on DE10-Lite board with USB Blaster by default. This configuration can be used as example for other JTAG debuggers/other JTAG debuggers/OpenOCD configurations . Please check RISCV-OpenOCD for more details. adapter driver usb_blaster transport select jtag adapter speed 1000 adapter srst delay 260 jtag_ntrst_delay 250 if { [ info exists CPUTAPID ] } { set _CPUTAPID $CPUTAPID } else { # set useful default set _CPUTAPID 0x0cafe001 } set _CHIPNAME neorv32 jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID set _TARGETNAME $_CHIPNAME .cpu target create $_TARGETNAME .0 riscv -chain-position $_TARGETNAME # work area (\"scratch pad RAM\"): beginning of internal DMEM, 256 bytes, REQUIRES backup $_TARGETNAME .0 configure -work-area-phys 0x80000000 -work-area-size 256 -work-area-backup 1","title":"Altera DE10 Lite"},{"location":"manual/hardware/de10-lite/#altera-de10-lite","text":"The following board and JTAG Debugger have been tested with RISC-V Studio FPGA Board: DE10-Lite JTAG Debugger: USB Bus Blaster JTAG Debugger is connected to FPGA board via extension IO header as in the following picture On the Linux environment, the following rules need to be added to the file /etc/udev/rules.d/51-usbblaster.rules to allow the USB devices are recognized and be accessed by the IDE Note: The vendor ID and Product ID can be obtained using lsusb command # USB-Blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6001\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6002\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6003\" , MODE = \"0666\" , GROUP = \"plugdev\" # USB-Blaster II SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6010\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6810\" , MODE = \"0666\" , GROUP = \"plugdev\" Replug the USB cables from the PC to take effect.","title":"Altera DE10 Lite"},{"location":"manual/hardware/de10-lite/#openocd-reference-configuration","text":"The following OpenOCD configuration is used to debug RISC-V on DE10-Lite board with USB Blaster by default. This configuration can be used as example for other JTAG debuggers/other JTAG debuggers/OpenOCD configurations . Please check RISCV-OpenOCD for more details. adapter driver usb_blaster transport select jtag adapter speed 1000 adapter srst delay 260 jtag_ntrst_delay 250 if { [ info exists CPUTAPID ] } { set _CPUTAPID $CPUTAPID } else { # set useful default set _CPUTAPID 0x0cafe001 } set _CHIPNAME neorv32 jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID set _TARGETNAME $_CHIPNAME .cpu target create $_TARGETNAME .0 riscv -chain-position $_TARGETNAME # work area (\"scratch pad RAM\"): beginning of internal DMEM, 256 bytes, REQUIRES backup $_TARGETNAME .0 configure -work-area-phys 0x80000000 -work-area-size 256 -work-area-backup 1","title":"OpenOCD reference configuration"},{"location":"manual/hardware/de2-115/","text":"Intel Altera DE2-115 \u00b6 The following board and JTAG Debugger have been tested with RISC-V Studio FPGA Board: DE2-115 JTAG Debugger: Bus Blaster v3 JTAG Debugger is connected to FPGA board via extension IO header as in the following picture On the Linux environment, the following rules need to be added to the file /etc/udev/rules.d/51-usbblaster.rules to allow the USB devices are recognized and be accessed by the IDE Note: The vendor ID and Product ID can be obtained using lsusb command # USB-Blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6001\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6002\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6003\" , MODE = \"0666\" , GROUP = \"plugdev\" # USB-Blaster II SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6010\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6810\" , MODE = \"0666\" , GROUP = \"plugdev\" # Bus blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"0403\" , ATTR { idProduct }== \"7780\" , MODE = \"0666\" , GROUP = \"plugdev\" Replug the USB cables from the PC to take effect. OpenOCD reference configuration \u00b6 The following OpenOCD configuration is used to debug RISC-V on DE2-115 board with Bus Blaster v3 by default. This configuration can be used as example for other JTAG debuggers/OpenOCD configuration . Please check RISCV-OpenOCD for more details. adapter driver ftdi transport select jtag # vendor id and product id of Bus blaster v3 ftdi vid_pid 0x0403 0x7780 ftdi layout_init 0x0c08 0x0f1b ftdi layout_signal nTRST -data 0x0100 -noe 0x0400 ftdi layout_signal nSRST -data 0x0200 -noe 0x0800 adapter speed 1000 adapter srst delay 260 jtag_ntrst_delay 250 if { [ info exists CPUTAPID ] } { set _CPUTAPID $CPUTAPID } else { # set useful default set _CPUTAPID 0x0cafe001 } set _CHIPNAME neorv32 jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID set _TARGETNAME $_CHIPNAME .cpu target create $_TARGETNAME .0 riscv -chain-position $_TARGETNAME # work area (\"scratch pad RAM\"): beginning of internal DMEM, 256 bytes, REQUIRES backup $_TARGETNAME .0 configure -work-area-phys 0x80000000 -work-area-size 256 -work-area-backup 1","title":"Altera DE2-115"},{"location":"manual/hardware/de2-115/#intel-altera-de2-115","text":"The following board and JTAG Debugger have been tested with RISC-V Studio FPGA Board: DE2-115 JTAG Debugger: Bus Blaster v3 JTAG Debugger is connected to FPGA board via extension IO header as in the following picture On the Linux environment, the following rules need to be added to the file /etc/udev/rules.d/51-usbblaster.rules to allow the USB devices are recognized and be accessed by the IDE Note: The vendor ID and Product ID can be obtained using lsusb command # USB-Blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6001\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6002\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6003\" , MODE = \"0666\" , GROUP = \"plugdev\" # USB-Blaster II SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6010\" , MODE = \"0666\" , GROUP = \"plugdev\" SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"09fb\" , ATTR { idProduct }== \"6810\" , MODE = \"0666\" , GROUP = \"plugdev\" # Bus blaster SUBSYSTEM == \"usb\" , ATTR { idVendor }== \"0403\" , ATTR { idProduct }== \"7780\" , MODE = \"0666\" , GROUP = \"plugdev\" Replug the USB cables from the PC to take effect.","title":"Intel Altera DE2-115"},{"location":"manual/hardware/de2-115/#openocd-reference-configuration","text":"The following OpenOCD configuration is used to debug RISC-V on DE2-115 board with Bus Blaster v3 by default. This configuration can be used as example for other JTAG debuggers/OpenOCD configuration . Please check RISCV-OpenOCD for more details. adapter driver ftdi transport select jtag # vendor id and product id of Bus blaster v3 ftdi vid_pid 0x0403 0x7780 ftdi layout_init 0x0c08 0x0f1b ftdi layout_signal nTRST -data 0x0100 -noe 0x0400 ftdi layout_signal nSRST -data 0x0200 -noe 0x0800 adapter speed 1000 adapter srst delay 260 jtag_ntrst_delay 250 if { [ info exists CPUTAPID ] } { set _CPUTAPID $CPUTAPID } else { # set useful default set _CPUTAPID 0x0cafe001 } set _CHIPNAME neorv32 jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID set _TARGETNAME $_CHIPNAME .cpu target create $_TARGETNAME .0 riscv -chain-position $_TARGETNAME # work area (\"scratch pad RAM\"): beginning of internal DMEM, 256 bytes, REQUIRES backup $_TARGETNAME .0 configure -work-area-phys 0x80000000 -work-area-size 256 -work-area-backup 1","title":"OpenOCD reference configuration"}]}